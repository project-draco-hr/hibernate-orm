{
  this.serviceRegistry=metadataSources.getServiceRegistry();
  this.options=options;
  this.identifierGeneratorFactory=serviceRegistry.getService(MutableIdentifierGeneratorFactory.class);
  this.database=new Database(options);
  this.mappingDefaults=new MappingDefaultsImpl();
  final MetadataSourceProcessor[] metadataSourceProcessors;
  if (options.getMetadataSourceProcessingOrder() == MetadataSourceProcessingOrder.HBM_FIRST) {
    metadataSourceProcessors=new MetadataSourceProcessor[]{new HbmMetadataSourceProcessorImpl(this),new AnnotationMetadataSourceProcessorImpl(this)};
  }
 else {
    metadataSourceProcessors=new MetadataSourceProcessor[]{new AnnotationMetadataSourceProcessorImpl(this),new HbmMetadataSourceProcessorImpl(this)};
  }
  this.classLoaderService=new ValueHolder<ClassLoaderService>(new ValueHolder.DeferredInitializer<ClassLoaderService>(){
    @Override public ClassLoaderService initialize(){
      return serviceRegistry.getService(ClassLoaderService.class);
    }
  }
);
  this.persisterClassResolverService=new ValueHolder<PersisterClassResolver>(new ValueHolder.DeferredInitializer<PersisterClassResolver>(){
    @Override public PersisterClassResolver initialize(){
      return serviceRegistry.getService(PersisterClassResolver.class);
    }
  }
);
  final ArrayList<String> processedEntityNames=new ArrayList<String>();
  prepare(metadataSourceProcessors,metadataSources);
  bindIndependentMetadata(metadataSourceProcessors,metadataSources);
  bindTypeDependentMetadata(metadataSourceProcessors,metadataSources);
  bindMappingMetadata(metadataSourceProcessors,metadataSources,processedEntityNames);
  bindMappingDependentMetadata(metadataSourceProcessors,metadataSources);
  new AssociationResolver(this).resolve();
  new HibernateTypeResolver(this).resolve();
  new IdentifierGeneratorResolver(this).resolve();
}
