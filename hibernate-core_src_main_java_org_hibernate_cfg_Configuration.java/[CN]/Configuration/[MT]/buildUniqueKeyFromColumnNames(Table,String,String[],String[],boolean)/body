{
  int size=columnNames.length;
  Column[] columns=new Column[size];
  Set<Column> unbound=new HashSet<Column>();
  Set<Column> unboundNoLogical=new HashSet<Column>();
  for (int index=0; index < size; index++) {
    String column=columnNames[index];
    try {
      final String columnName=createMappings().getPhysicalColumnName(column,table);
      columns[index]=new Column(columnName);
      unbound.add(columns[index]);
    }
 catch (    MappingException e) {
      unboundNoLogical.add(new Column(column));
    }
  }
  if (StringHelper.isEmpty(keyName)) {
    keyName=Constraint.generateName("UK_",table,columns);
  }
  keyName=normalizer.normalizeIdentifierQuoting(keyName);
  if (unique) {
    UniqueKey uk=table.getOrCreateUniqueKey(keyName);
    for (int i=0; i < columns.length; i++) {
      Column column=columns[i];
      String order=orderings != null ? orderings[i] : null;
      if (table.containsColumn(column)) {
        uk.addColumn(column,order);
        unbound.remove(column);
      }
    }
  }
 else {
    Index index=table.getOrCreateIndex(keyName);
    for (int i=0; i < columns.length; i++) {
      Column column=columns[i];
      String order=orderings != null ? orderings[i] : null;
      if (table.containsColumn(column)) {
        index.addColumn(column,order);
        unbound.remove(column);
      }
    }
  }
  if (unbound.size() > 0 || unboundNoLogical.size() > 0) {
    StringBuilder sb=new StringBuilder("Unable to create unique key constraint (");
    for (    String columnName : columnNames) {
      sb.append(columnName).append(", ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(") on table ").append(table.getName()).append(": database column ");
    for (    Column column : unbound) {
      sb.append("'").append(column.getName()).append("', ");
    }
    for (    Column column : unboundNoLogical) {
      sb.append("'").append(column.getName()).append("', ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(" not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)");
    throw new AnnotationException(sb.toString());
  }
}
