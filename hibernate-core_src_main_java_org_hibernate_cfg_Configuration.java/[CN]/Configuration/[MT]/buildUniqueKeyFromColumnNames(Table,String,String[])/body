{
  keyName=normalizer.normalizeIdentifierQuoting(keyName);
  int size=columnNames.length;
  Column[] columns=new Column[size];
  Set<Column> unbound=new HashSet<Column>();
  Set<Column> unboundNoLogical=new HashSet<Column>();
  for (int index=0; index < size; index++) {
    final String logicalColumnName=normalizer.normalizeIdentifierQuoting(columnNames[index]);
    try {
      final String columnName=createMappings().getPhysicalColumnName(logicalColumnName,table);
      columns[index]=new Column(columnName);
      unbound.add(columns[index]);
    }
 catch (    MappingException e) {
      unboundNoLogical.add(new Column(logicalColumnName));
    }
  }
  for (  Column column : columns) {
    if (table.containsColumn(column)) {
      Column tableColumn=table.getColumn(column);
      tableColumn.setUnique(true);
      Dialect.getDialect().getUniqueDelegate().generateUniqueKey(table,tableColumn);
      unbound.remove(column);
    }
  }
  if (unbound.size() > 0 || unboundNoLogical.size() > 0) {
    StringBuilder sb=new StringBuilder("Unable to create unique key constraint (");
    for (    String columnName : columnNames) {
      sb.append(columnName).append(", ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(") on table ").append(table.getName()).append(": database column ");
    for (    Column column : unbound) {
      sb.append(column.getName()).append(", ");
    }
    for (    Column column : unboundNoLogical) {
      sb.append(column.getName()).append(", ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(" not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)");
    throw new AnnotationException(sb.toString());
  }
}
