{
  localAccessStrategy.putFromLoad(KEY,VALUE1,System.currentTimeMillis(),new Integer(1));
  remoteAccessStrategy.putFromLoad(KEY,VALUE1,System.currentTimeMillis(),new Integer(1));
  sleep(250);
  final CountDownLatch readLatch=new CountDownLatch(1);
  final CountDownLatch commitLatch=new CountDownLatch(1);
  final CountDownLatch completionLatch=new CountDownLatch(2);
  Thread updater=new Thread(){
    public void run(){
      try {
        long txTimestamp=System.currentTimeMillis();
        BatchModeTransactionManager.getInstance().begin();
        assertEquals("Correct initial value",VALUE1,localAccessStrategy.get(KEY,txTimestamp));
        localAccessStrategy.update(KEY,VALUE2,new Integer(2),new Integer(1));
        readLatch.countDown();
        commitLatch.await();
        BatchModeTransactionManager.getInstance().commit();
      }
 catch (      Exception e) {
        log.error("node1 caught exception",e);
        node1Exception=e;
        rollback();
      }
catch (      AssertionFailedError e) {
        node1Failure=e;
        rollback();
      }
 finally {
        completionLatch.countDown();
      }
    }
  }
;
  Thread reader=new Thread(){
    public void run(){
      try {
        long txTimestamp=System.currentTimeMillis();
        BatchModeTransactionManager.getInstance().begin();
        readLatch.await();
        Object expected=isUsingOptimisticLocking() ? VALUE1 : VALUE2;
        assertEquals("Correct value",expected,localAccessStrategy.get(KEY,txTimestamp));
        BatchModeTransactionManager.getInstance().commit();
      }
 catch (      Exception e) {
        log.error("node1 caught exception",e);
        node1Exception=e;
        rollback();
      }
catch (      AssertionFailedError e) {
        node1Failure=e;
        rollback();
      }
 finally {
        commitLatch.countDown();
        completionLatch.countDown();
      }
    }
  }
;
  updater.setDaemon(true);
  reader.setDaemon(true);
  updater.start();
  reader.start();
  if (isUsingOptimisticLocking())   assertTrue(completionLatch.await(1,TimeUnit.SECONDS));
 else {
    assertFalse(completionLatch.await(250,TimeUnit.MILLISECONDS));
    commitLatch.countDown();
    assertTrue(completionLatch.await(1,TimeUnit.SECONDS));
  }
  if (node1Failure != null)   throw node1Failure;
  if (node2Failure != null)   throw node2Failure;
  assertEquals("node1 saw no exceptions",null,node1Exception);
  assertEquals("node2 saw no exceptions",null,node2Exception);
  long txTimestamp=System.currentTimeMillis();
  assertEquals("Correct node1 value",VALUE2,localAccessStrategy.get(KEY,txTimestamp));
  Object expected=isUsingInvalidation() ? null : VALUE2;
  assertEquals("Correct node2 value",expected,remoteAccessStrategy.get(KEY,txTimestamp));
}
