{
  LOG.debugf("Starting fillSimpleValue for %s",propertyName);
  if (attributeConverterDefinition != null) {
    if (!BinderHelper.isEmptyAnnotationValue(explicitType)) {
      throw new AnnotationException(String.format("AttributeConverter and explicit Type cannot be applied to same attribute [%s.%s];" + "remove @Type or specify @Convert(disableConversion = true)",persistentClassName,propertyName));
    }
    LOG.debugf("Applying JPA AttributeConverter [%s] to [%s:%s]",attributeConverterDefinition,persistentClassName,propertyName);
    simpleValue.setJpaAttributeConverterDefinition(attributeConverterDefinition);
  }
 else {
    String type;
    TypeDefinition typeDef;
    if (!BinderHelper.isEmptyAnnotationValue(explicitType)) {
      type=explicitType;
      typeDef=buildingContext.getMetadataCollector().getTypeDefinition(type);
    }
 else {
      TypeDefinition implicitTypeDef=buildingContext.getMetadataCollector().getTypeDefinition(returnedClassName);
      if (implicitTypeDef != null) {
        typeDef=implicitTypeDef;
        type=returnedClassName;
      }
 else {
        typeDef=buildingContext.getMetadataCollector().getTypeDefinition(defaultType);
        type=defaultType;
      }
    }
    if (typeDef != null) {
      type=typeDef.getTypeImplementorClass().getName();
      simpleValue.setTypeParameters(typeDef.getParametersAsProperties());
    }
    if (typeParameters != null && typeParameters.size() != 0) {
      simpleValue.setTypeParameters(typeParameters);
    }
    simpleValue.setTypeName(type);
  }
  if (persistentClassName != null || attributeConverterDefinition != null) {
    try {
      simpleValue.setTypeUsingReflection(persistentClassName,propertyName);
    }
 catch (    Exception e) {
      throw new MappingException(String.format(Locale.ROOT,"Unable to determine basic type mapping via reflection [%s -> %s]",persistentClassName,propertyName),e);
    }
  }
  if (!simpleValue.isTypeSpecified() && isVersion()) {
    simpleValue.setTypeName("integer");
  }
  if (timeStampVersionType != null) {
    simpleValue.setTypeName(timeStampVersionType);
  }
  if (simpleValue.getTypeName() != null && simpleValue.getTypeName().length() > 0 && simpleValue.getMetadata().getTypeResolver().basic(simpleValue.getTypeName()) == null) {
    try {
      Class typeClass=buildingContext.getClassLoaderAccess().classForName(simpleValue.getTypeName());
      if (typeClass != null && DynamicParameterizedType.class.isAssignableFrom(typeClass)) {
        Properties parameters=simpleValue.getTypeParameters();
        if (parameters == null) {
          parameters=new Properties();
        }
        parameters.put(DynamicParameterizedType.IS_DYNAMIC,Boolean.toString(true));
        parameters.put(DynamicParameterizedType.RETURNED_CLASS,returnedClassName);
        parameters.put(DynamicParameterizedType.IS_PRIMARY_KEY,Boolean.toString(key));
        parameters.put(DynamicParameterizedType.ENTITY,persistentClassName);
        parameters.put(DynamicParameterizedType.XPROPERTY,xproperty);
        parameters.put(DynamicParameterizedType.PROPERTY,xproperty.getName());
        parameters.put(DynamicParameterizedType.ACCESS_TYPE,accessType.getType());
        simpleValue.setTypeParameters(parameters);
      }
    }
 catch (    ClassLoadingException e) {
      throw new MappingException("Could not determine type for: " + simpleValue.getTypeName(),e);
    }
  }
}
