{
switch (x.getType()) {
case OR:
    x.setType(AND);
  x.setText("{and}");
x.setFirstChild(negateNode(x.getFirstChild()));
x.getFirstChild().setNextSibling(negateNode(x.getFirstChild().getNextSibling()));
return x;
case AND:
x.setType(OR);
x.setText("{or}");
x.setFirstChild(negateNode(x.getFirstChild()));
x.getFirstChild().setNextSibling(negateNode(x.getFirstChild().getNextSibling()));
return x;
case EQ:
x.setType(NE);
x.setText("{not}" + x.getText());
return x;
case NE:
x.setType(EQ);
x.setText("{not}" + x.getText());
return x;
case GT:
x.setType(LE);
x.setText("{not}" + x.getText());
return x;
case LT:
x.setType(GE);
x.setText("{not}" + x.getText());
return x;
case GE:
x.setType(LT);
x.setText("{not}" + x.getText());
return x;
case LE:
x.setType(GT);
x.setText("{not}" + x.getText());
return x;
case LIKE:
x.setType(NOT_LIKE);
x.setText("{not}" + x.getText());
return x;
case NOT_LIKE:
x.setType(LIKE);
x.setText("{not}" + x.getText());
return x;
case IN:
x.setType(NOT_IN);
x.setText("{not}" + x.getText());
return x;
case NOT_IN:
x.setType(IN);
x.setText("{not}" + x.getText());
return x;
case IS_NULL:
x.setType(IS_NOT_NULL);
x.setText("{not}" + x.getText());
return x;
case IS_NOT_NULL:
x.setType(IS_NULL);
x.setText("{not}" + x.getText());
return x;
case BETWEEN:
x.setType(NOT_BETWEEN);
x.setText("{not}" + x.getText());
return x;
case NOT_BETWEEN:
x.setType(BETWEEN);
x.setText("{not}" + x.getText());
return x;
default :
AST not=super.negateNode(x);
if (not != x) {
not.setNextSibling(x.getNextSibling());
x.setNextSibling(null);
}
return not;
}
}
