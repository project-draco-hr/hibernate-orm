{
  EntityManager em=getOrCreateEntityManager();
  final EntityManager em2=createIsolatedEntityManager();
  try {
    Lock lock=new Lock();
    lock.setName("name");
    em.getTransaction().begin();
    em.persist(lock);
    em.getTransaction().commit();
    em.getTransaction().begin();
    lock=em.getReference(Lock.class,lock.getId());
    final Integer id=lock.getId();
    em.lock(lock,LockModeType.READ);
    em.lock(lock,LockModeType.OPTIMISTIC_FORCE_INCREMENT);
    lock.setName("surname");
    final CountDownLatch latch=new CountDownLatch(1);
    Thread t=new Thread(new Runnable(){
      public void run(){
        try {
          em2.getTransaction().begin();
          Lock lock2=em2.getReference(Lock.class,id);
          lock2.setName("renamed");
        }
  finally {
          em2.getTransaction().commit();
          em2.close();
          latch.countDown();
        }
      }
    }
);
    t.setDaemon(true);
    t.setName("testUpgradeReadLockToOptimisticForceIncrement tx2");
    t.start();
    log.info("testUpgradeReadLockToOptimisticForceIncrement:  wait on BG thread");
    boolean latchSet=latch.await(10,TimeUnit.SECONDS);
    assertTrue("background test thread finished (lock timeout is broken)",latchSet);
    try {
      em.getTransaction().commit();
    }
 catch (    Throwable expectedToFail) {
      while (expectedToFail != null && !(expectedToFail instanceof javax.persistence.OptimisticLockException)) {
        expectedToFail=expectedToFail.getCause();
      }
      assertTrue("upgrade to OPTIMISTIC_FORCE_INCREMENT is expected to fail at end of transaction1 since tranaction2 already updated the entity",expectedToFail instanceof javax.persistence.OptimisticLockException);
    }
  }
  finally {
    em.close();
  }
}
