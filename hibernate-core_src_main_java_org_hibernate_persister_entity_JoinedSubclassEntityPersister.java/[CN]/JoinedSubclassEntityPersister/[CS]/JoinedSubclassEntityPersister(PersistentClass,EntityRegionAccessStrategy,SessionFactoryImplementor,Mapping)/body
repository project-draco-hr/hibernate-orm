{
  super(persistentClass,cacheAccessStrategy,factory);
  final Object discriminatorValue;
  if (persistentClass.isPolymorphic()) {
    try {
      discriminatorValue=new Integer(persistentClass.getSubclassId());
      discriminatorSQLString=discriminatorValue.toString();
    }
 catch (    Exception e) {
      throw new MappingException("Could not format discriminator value to SQL string",e);
    }
  }
 else {
    discriminatorValue=null;
    discriminatorSQLString=null;
  }
  if (optimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION) {
    throw new MappingException("optimistic-lock=all|dirty not supported for joined-subclass mappings [" + getEntityName() + "]");
  }
  final int idColumnSpan=getIdentifierColumnSpan();
  ArrayList tables=new ArrayList();
  ArrayList keyColumns=new ArrayList();
  ArrayList keyColumnReaders=new ArrayList();
  ArrayList keyColumnReaderTemplates=new ArrayList();
  ArrayList cascadeDeletes=new ArrayList();
  Iterator titer=persistentClass.getTableClosureIterator();
  Iterator kiter=persistentClass.getKeyClosureIterator();
  while (titer.hasNext()) {
    Table tab=(Table)titer.next();
    KeyValue key=(KeyValue)kiter.next();
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    tables.add(tabname);
    String[] keyCols=new String[idColumnSpan];
    String[] keyColReaders=new String[idColumnSpan];
    String[] keyColReaderTemplates=new String[idColumnSpan];
    Iterator citer=key.getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      Column column=(Column)citer.next();
      keyCols[k]=column.getQuotedName(factory.getDialect());
      keyColReaders[k]=column.getReadExpr(factory.getDialect());
      keyColReaderTemplates[k]=column.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
    }
    keyColumns.add(keyCols);
    keyColumnReaders.add(keyColReaders);
    keyColumnReaderTemplates.add(keyColReaderTemplates);
    cascadeDeletes.add(key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete());
  }
  coreTableSpan=tables.size();
  isNullableTable=new boolean[persistentClass.getJoinClosureSpan()];
  int tabIndex=0;
  Iterator joinIter=persistentClass.getJoinClosureIterator();
  while (joinIter.hasNext()) {
    Join join=(Join)joinIter.next();
    isNullableTable[tabIndex++]=join.isOptional();
    Table tab=join.getTable();
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    tables.add(tabname);
    KeyValue key=join.getKey();
    int joinIdColumnSpan=key.getColumnSpan();
    String[] keyCols=new String[joinIdColumnSpan];
    String[] keyColReaders=new String[joinIdColumnSpan];
    String[] keyColReaderTemplates=new String[joinIdColumnSpan];
    Iterator citer=key.getColumnIterator();
    for (int k=0; k < joinIdColumnSpan; k++) {
      Column column=(Column)citer.next();
      keyCols[k]=column.getQuotedName(factory.getDialect());
      keyColReaders[k]=column.getReadExpr(factory.getDialect());
      keyColReaderTemplates[k]=column.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
    }
    keyColumns.add(keyCols);
    keyColumnReaders.add(keyColReaders);
    keyColumnReaderTemplates.add(keyColReaderTemplates);
    cascadeDeletes.add(key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete());
  }
  naturalOrderTableNames=ArrayHelper.toStringArray(tables);
  naturalOrderTableKeyColumns=ArrayHelper.to2DStringArray(keyColumns);
  naturalOrderTableKeyColumnReaders=ArrayHelper.to2DStringArray(keyColumnReaders);
  naturalOrderTableKeyColumnReaderTemplates=ArrayHelper.to2DStringArray(keyColumnReaderTemplates);
  naturalOrderCascadeDeleteEnabled=ArrayHelper.toBooleanArray(cascadeDeletes);
  ArrayList subtables=new ArrayList();
  ArrayList isConcretes=new ArrayList();
  ArrayList isDeferreds=new ArrayList();
  ArrayList isLazies=new ArrayList();
  keyColumns=new ArrayList();
  titer=persistentClass.getSubclassTableClosureIterator();
  while (titer.hasNext()) {
    Table tab=(Table)titer.next();
    isConcretes.add(persistentClass.isClassOrSuperclassTable(tab));
    isDeferreds.add(Boolean.FALSE);
    isLazies.add(Boolean.FALSE);
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    subtables.add(tabname);
    String[] key=new String[idColumnSpan];
    Iterator citer=tab.getPrimaryKey().getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      key[k]=((Column)citer.next()).getQuotedName(factory.getDialect());
    }
    keyColumns.add(key);
  }
  joinIter=persistentClass.getSubclassJoinClosureIterator();
  while (joinIter.hasNext()) {
    Join join=(Join)joinIter.next();
    Table tab=join.getTable();
    isConcretes.add(persistentClass.isClassOrSuperclassTable(tab));
    isDeferreds.add(join.isSequentialSelect());
    isLazies.add(join.isLazy());
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    subtables.add(tabname);
    String[] key=new String[idColumnSpan];
    Iterator citer=tab.getPrimaryKey().getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      key[k]=((Column)citer.next()).getQuotedName(factory.getDialect());
    }
    keyColumns.add(key);
  }
  String[] naturalOrderSubclassTableNameClosure=ArrayHelper.toStringArray(subtables);
  String[][] naturalOrderSubclassTableKeyColumnClosure=ArrayHelper.to2DStringArray(keyColumns);
  isClassOrSuperclassTable=ArrayHelper.toBooleanArray(isConcretes);
  subclassTableSequentialSelect=ArrayHelper.toBooleanArray(isDeferreds);
  subclassTableIsLazyClosure=ArrayHelper.toBooleanArray(isLazies);
  constraintOrderedTableNames=new String[naturalOrderSubclassTableNameClosure.length];
  constraintOrderedKeyColumnNames=new String[naturalOrderSubclassTableNameClosure.length][];
  int currentPosition=0;
  for (int i=naturalOrderSubclassTableNameClosure.length - 1; i >= 0; i--, currentPosition++) {
    constraintOrderedTableNames[currentPosition]=naturalOrderSubclassTableNameClosure[i];
    constraintOrderedKeyColumnNames[currentPosition]=naturalOrderSubclassTableKeyColumnClosure[i];
  }
  tableSpan=naturalOrderTableNames.length;
  tableNames=reverse(naturalOrderTableNames,coreTableSpan);
  tableKeyColumns=reverse(naturalOrderTableKeyColumns,coreTableSpan);
  tableKeyColumnReaders=reverse(naturalOrderTableKeyColumnReaders,coreTableSpan);
  tableKeyColumnReaderTemplates=reverse(naturalOrderTableKeyColumnReaderTemplates,coreTableSpan);
  subclassTableNameClosure=reverse(naturalOrderSubclassTableNameClosure,coreTableSpan);
  subclassTableKeyColumnClosure=reverse(naturalOrderSubclassTableKeyColumnClosure,coreTableSpan);
  spaces=ArrayHelper.join(tableNames,ArrayHelper.toStringArray(persistentClass.getSynchronizedTables()));
  customSQLInsert=new String[tableSpan];
  customSQLUpdate=new String[tableSpan];
  customSQLDelete=new String[tableSpan];
  insertCallable=new boolean[tableSpan];
  updateCallable=new boolean[tableSpan];
  deleteCallable=new boolean[tableSpan];
  insertResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  updateResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  deleteResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  PersistentClass pc=persistentClass;
  int jk=coreTableSpan - 1;
  while (pc != null) {
    customSQLInsert[jk]=pc.getCustomSQLInsert();
    insertCallable[jk]=customSQLInsert[jk] != null && pc.isCustomInsertCallable();
    insertResultCheckStyles[jk]=pc.getCustomSQLInsertCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLInsert[jk],insertCallable[jk]) : pc.getCustomSQLInsertCheckStyle();
    customSQLUpdate[jk]=pc.getCustomSQLUpdate();
    updateCallable[jk]=customSQLUpdate[jk] != null && pc.isCustomUpdateCallable();
    updateResultCheckStyles[jk]=pc.getCustomSQLUpdateCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLUpdate[jk],updateCallable[jk]) : pc.getCustomSQLUpdateCheckStyle();
    customSQLDelete[jk]=pc.getCustomSQLDelete();
    deleteCallable[jk]=customSQLDelete[jk] != null && pc.isCustomDeleteCallable();
    deleteResultCheckStyles[jk]=pc.getCustomSQLDeleteCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLDelete[jk],deleteCallable[jk]) : pc.getCustomSQLDeleteCheckStyle();
    jk--;
    pc=pc.getSuperclass();
  }
  if (jk != -1) {
    throw new AssertionFailure("Tablespan does not match height of joined-subclass hiearchy.");
  }
  joinIter=persistentClass.getJoinClosureIterator();
  int j=coreTableSpan;
  while (joinIter.hasNext()) {
    Join join=(Join)joinIter.next();
    customSQLInsert[j]=join.getCustomSQLInsert();
    insertCallable[j]=customSQLInsert[j] != null && join.isCustomInsertCallable();
    insertResultCheckStyles[j]=join.getCustomSQLInsertCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLInsert[j],insertCallable[j]) : join.getCustomSQLInsertCheckStyle();
    customSQLUpdate[j]=join.getCustomSQLUpdate();
    updateCallable[j]=customSQLUpdate[j] != null && join.isCustomUpdateCallable();
    updateResultCheckStyles[j]=join.getCustomSQLUpdateCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLUpdate[j],updateCallable[j]) : join.getCustomSQLUpdateCheckStyle();
    customSQLDelete[j]=join.getCustomSQLDelete();
    deleteCallable[j]=customSQLDelete[j] != null && join.isCustomDeleteCallable();
    deleteResultCheckStyles[j]=join.getCustomSQLDeleteCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLDelete[j],deleteCallable[j]) : join.getCustomSQLDeleteCheckStyle();
    j++;
  }
  int hydrateSpan=getPropertySpan();
  naturalOrderPropertyTableNumbers=new int[hydrateSpan];
  propertyTableNumbers=new int[hydrateSpan];
  Iterator iter=persistentClass.getPropertyClosureIterator();
  int i=0;
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    String tabname=prop.getValue().getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    propertyTableNumbers[i]=getTableId(tabname,tableNames);
    naturalOrderPropertyTableNumbers[i]=getTableId(tabname,naturalOrderTableNames);
    i++;
  }
  ArrayList columnTableNumbers=new ArrayList();
  ArrayList formulaTableNumbers=new ArrayList();
  ArrayList propTableNumbers=new ArrayList();
  iter=persistentClass.getSubclassPropertyClosureIterator();
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    Table tab=prop.getValue().getTable();
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    Integer tabnum=new Integer(getTableId(tabname,subclassTableNameClosure));
    propTableNumbers.add(tabnum);
    Iterator citer=prop.getColumnIterator();
    while (citer.hasNext()) {
      Selectable thing=(Selectable)citer.next();
      if (thing.isFormula()) {
        formulaTableNumbers.add(tabnum);
      }
 else {
        columnTableNumbers.add(tabnum);
      }
    }
  }
  subclassColumnTableNumberClosure=ArrayHelper.toIntArray(columnTableNumbers);
  subclassPropertyTableNumberClosure=ArrayHelper.toIntArray(propTableNumbers);
  subclassFormulaTableNumberClosure=ArrayHelper.toIntArray(formulaTableNumbers);
  int subclassSpan=persistentClass.getSubclassSpan() + 1;
  subclassClosure=new String[subclassSpan];
  subclassClosure[subclassSpan - 1]=getEntityName();
  if (persistentClass.isPolymorphic()) {
    subclassesByDiscriminatorValue.put(discriminatorValue,getEntityName());
    discriminatorValues=new String[subclassSpan];
    discriminatorValues[subclassSpan - 1]=discriminatorSQLString;
    notNullColumnTableNumbers=new int[subclassSpan];
    final int id=getTableId(persistentClass.getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName()),subclassTableNameClosure);
    notNullColumnTableNumbers[subclassSpan - 1]=id;
    notNullColumnNames=new String[subclassSpan];
    notNullColumnNames[subclassSpan - 1]=subclassTableKeyColumnClosure[id][0];
  }
 else {
    discriminatorValues=null;
    notNullColumnTableNumbers=null;
    notNullColumnNames=null;
  }
  iter=persistentClass.getSubclassIterator();
  int k=0;
  while (iter.hasNext()) {
    Subclass sc=(Subclass)iter.next();
    subclassClosure[k]=sc.getEntityName();
    try {
      if (persistentClass.isPolymorphic()) {
        Integer subclassId=new Integer(sc.getSubclassId());
        subclassesByDiscriminatorValue.put(subclassId,sc.getEntityName());
        discriminatorValues[k]=subclassId.toString();
        int id=getTableId(sc.getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName()),subclassTableNameClosure);
        notNullColumnTableNumbers[k]=id;
        notNullColumnNames[k]=subclassTableKeyColumnClosure[id][0];
      }
    }
 catch (    Exception e) {
      throw new MappingException("Error parsing discriminator value",e);
    }
    k++;
  }
  initLockers();
  initSubclassPropertyAliasesMap(persistentClass);
  postConstruct(mapping);
}
