{
  super(persistentClass,cacheAccessStrategy,naturalIdRegionAccessStrategy,creationContext);
  final SessionFactoryImplementor factory=creationContext.getSessionFactory();
  final Database database=creationContext.getMetadata().getDatabase();
  final JdbcEnvironment jdbcEnvironment=database.getJdbcEnvironment();
  if (persistentClass.isPolymorphic()) {
    final Value discriminatorMapping=persistentClass.getDiscriminator();
    if (discriminatorMapping != null) {
      log.debug("Encountered explicit discriminator mapping for joined inheritance");
      final Selectable selectable=discriminatorMapping.getColumnIterator().next();
      if (Formula.class.isInstance(selectable)) {
        throw new MappingException("Discriminator formulas on joined inheritance hierarchies not supported at this time");
      }
 else {
        final Column column=(Column)selectable;
        explicitDiscriminatorColumnName=column.getQuotedName(factory.getDialect());
        discriminatorAlias=column.getAlias(factory.getDialect(),persistentClass.getRootTable());
      }
      discriminatorType=(DiscriminatorType)persistentClass.getDiscriminator().getType();
      if (persistentClass.isDiscriminatorValueNull()) {
        discriminatorValue=NULL_DISCRIMINATOR;
        discriminatorSQLString=InFragment.NULL;
      }
 else       if (persistentClass.isDiscriminatorValueNotNull()) {
        discriminatorValue=NOT_NULL_DISCRIMINATOR;
        discriminatorSQLString=InFragment.NOT_NULL;
      }
 else {
        try {
          discriminatorValue=discriminatorType.stringToObject(persistentClass.getDiscriminatorValue());
          discriminatorSQLString=discriminatorType.objectToSQLString(discriminatorValue,factory.getDialect());
        }
 catch (        ClassCastException cce) {
          throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
        }
catch (        Exception e) {
          throw new MappingException("Could not format discriminator value to SQL string",e);
        }
      }
    }
 else {
      explicitDiscriminatorColumnName=null;
      discriminatorAlias=IMPLICIT_DISCRIMINATOR_ALIAS;
      discriminatorType=StandardBasicTypes.INTEGER;
      try {
        discriminatorValue=persistentClass.getSubclassId();
        discriminatorSQLString=discriminatorValue.toString();
      }
 catch (      Exception e) {
        throw new MappingException("Could not format discriminator value to SQL string",e);
      }
    }
  }
 else {
    explicitDiscriminatorColumnName=null;
    discriminatorAlias=IMPLICIT_DISCRIMINATOR_ALIAS;
    discriminatorType=StandardBasicTypes.INTEGER;
    discriminatorValue=null;
    discriminatorSQLString=null;
  }
  if (optimisticLockStyle() == OptimisticLockStyle.ALL || optimisticLockStyle() == OptimisticLockStyle.DIRTY) {
    throw new MappingException("optimistic-lock=all|dirty not supported for joined-subclass mappings [" + getEntityName() + "]");
  }
  final int idColumnSpan=getIdentifierColumnSpan();
  ArrayList<String> tableNames=new ArrayList<String>();
  ArrayList<String[]> keyColumns=new ArrayList<String[]>();
  ArrayList<String[]> keyColumnReaders=new ArrayList<String[]>();
  ArrayList<String[]> keyColumnReaderTemplates=new ArrayList<String[]>();
  ArrayList<Boolean> cascadeDeletes=new ArrayList<Boolean>();
  Iterator tItr=persistentClass.getTableClosureIterator();
  Iterator kItr=persistentClass.getKeyClosureIterator();
  while (tItr.hasNext()) {
    final Table table=(Table)tItr.next();
    final KeyValue key=(KeyValue)kItr.next();
    final String tableName=determineTableName(table,jdbcEnvironment);
    tableNames.add(tableName);
    String[] keyCols=new String[idColumnSpan];
    String[] keyColReaders=new String[idColumnSpan];
    String[] keyColReaderTemplates=new String[idColumnSpan];
    Iterator cItr=key.getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      Column column=(Column)cItr.next();
      keyCols[k]=column.getQuotedName(factory.getDialect());
      keyColReaders[k]=column.getReadExpr(factory.getDialect());
      keyColReaderTemplates[k]=column.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
    }
    keyColumns.add(keyCols);
    keyColumnReaders.add(keyColReaders);
    keyColumnReaderTemplates.add(keyColReaderTemplates);
    cascadeDeletes.add(key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete());
  }
  coreTableSpan=tableNames.size();
  isNullableTable=new boolean[persistentClass.getJoinClosureSpan()];
  int tableIndex=0;
  Iterator joinItr=persistentClass.getJoinClosureIterator();
  while (joinItr.hasNext()) {
    Join join=(Join)joinItr.next();
    isNullableTable[tableIndex++]=join.isOptional();
    Table table=join.getTable();
    final String tableName=determineTableName(table,jdbcEnvironment);
    tableNames.add(tableName);
    KeyValue key=join.getKey();
    int joinIdColumnSpan=key.getColumnSpan();
    String[] keyCols=new String[joinIdColumnSpan];
    String[] keyColReaders=new String[joinIdColumnSpan];
    String[] keyColReaderTemplates=new String[joinIdColumnSpan];
    Iterator cItr=key.getColumnIterator();
    for (int k=0; k < joinIdColumnSpan; k++) {
      Column column=(Column)cItr.next();
      keyCols[k]=column.getQuotedName(factory.getDialect());
      keyColReaders[k]=column.getReadExpr(factory.getDialect());
      keyColReaderTemplates[k]=column.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
    }
    keyColumns.add(keyCols);
    keyColumnReaders.add(keyColReaders);
    keyColumnReaderTemplates.add(keyColReaderTemplates);
    cascadeDeletes.add(key.isCascadeDeleteEnabled() && factory.getDialect().supportsCascadeDelete());
  }
  naturalOrderTableNames=ArrayHelper.toStringArray(tableNames);
  naturalOrderTableKeyColumns=ArrayHelper.to2DStringArray(keyColumns);
  naturalOrderTableKeyColumnReaders=ArrayHelper.to2DStringArray(keyColumnReaders);
  naturalOrderTableKeyColumnReaderTemplates=ArrayHelper.to2DStringArray(keyColumnReaderTemplates);
  naturalOrderCascadeDeleteEnabled=ArrayHelper.toBooleanArray(cascadeDeletes);
  ArrayList<String> subclassTableNames=new ArrayList<String>();
  ArrayList<Boolean> isConcretes=new ArrayList<Boolean>();
  ArrayList<Boolean> isDeferreds=new ArrayList<Boolean>();
  ArrayList<Boolean> isLazies=new ArrayList<Boolean>();
  keyColumns=new ArrayList<String[]>();
  tItr=persistentClass.getSubclassTableClosureIterator();
  while (tItr.hasNext()) {
    Table tab=(Table)tItr.next();
    isConcretes.add(persistentClass.isClassOrSuperclassTable(tab));
    isDeferreds.add(Boolean.FALSE);
    isLazies.add(Boolean.FALSE);
    final String tableName=determineTableName(tab,jdbcEnvironment);
    subclassTableNames.add(tableName);
    String[] key=new String[idColumnSpan];
    Iterator cItr=tab.getPrimaryKey().getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      key[k]=((Column)cItr.next()).getQuotedName(factory.getDialect());
    }
    keyColumns.add(key);
  }
  joinItr=persistentClass.getSubclassJoinClosureIterator();
  while (joinItr.hasNext()) {
    final Join join=(Join)joinItr.next();
    final Table joinTable=join.getTable();
    isConcretes.add(persistentClass.isClassOrSuperclassTable(joinTable));
    isDeferreds.add(join.isSequentialSelect());
    isLazies.add(join.isLazy());
    String joinTableName=determineTableName(joinTable,jdbcEnvironment);
    subclassTableNames.add(joinTableName);
    String[] key=new String[idColumnSpan];
    Iterator citer=joinTable.getPrimaryKey().getColumnIterator();
    for (int k=0; k < idColumnSpan; k++) {
      key[k]=((Column)citer.next()).getQuotedName(factory.getDialect());
    }
    keyColumns.add(key);
  }
  String[] naturalOrderSubclassTableNameClosure=ArrayHelper.toStringArray(subclassTableNames);
  String[][] naturalOrderSubclassTableKeyColumnClosure=ArrayHelper.to2DStringArray(keyColumns);
  isClassOrSuperclassTable=ArrayHelper.toBooleanArray(isConcretes);
  subclassTableSequentialSelect=ArrayHelper.toBooleanArray(isDeferreds);
  subclassTableIsLazyClosure=ArrayHelper.toBooleanArray(isLazies);
  constraintOrderedTableNames=new String[naturalOrderSubclassTableNameClosure.length];
  constraintOrderedKeyColumnNames=new String[naturalOrderSubclassTableNameClosure.length][];
  int currentPosition=0;
  for (int i=naturalOrderSubclassTableNameClosure.length - 1; i >= 0; i--, currentPosition++) {
    constraintOrderedTableNames[currentPosition]=naturalOrderSubclassTableNameClosure[i];
    constraintOrderedKeyColumnNames[currentPosition]=naturalOrderSubclassTableKeyColumnClosure[i];
  }
  tableSpan=naturalOrderTableNames.length;
  this.tableNames=reverse(naturalOrderTableNames,coreTableSpan);
  tableKeyColumns=reverse(naturalOrderTableKeyColumns,coreTableSpan);
  tableKeyColumnReaders=reverse(naturalOrderTableKeyColumnReaders,coreTableSpan);
  tableKeyColumnReaderTemplates=reverse(naturalOrderTableKeyColumnReaderTemplates,coreTableSpan);
  subclassTableNameClosure=reverse(naturalOrderSubclassTableNameClosure,coreTableSpan);
  subclassTableKeyColumnClosure=reverse(naturalOrderSubclassTableKeyColumnClosure,coreTableSpan);
  spaces=ArrayHelper.join(this.tableNames,ArrayHelper.toStringArray(persistentClass.getSynchronizedTables()));
  customSQLInsert=new String[tableSpan];
  customSQLUpdate=new String[tableSpan];
  customSQLDelete=new String[tableSpan];
  insertCallable=new boolean[tableSpan];
  updateCallable=new boolean[tableSpan];
  deleteCallable=new boolean[tableSpan];
  insertResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  updateResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  deleteResultCheckStyles=new ExecuteUpdateResultCheckStyle[tableSpan];
  PersistentClass pc=persistentClass;
  int jk=coreTableSpan - 1;
  while (pc != null) {
    customSQLInsert[jk]=pc.getCustomSQLInsert();
    insertCallable[jk]=customSQLInsert[jk] != null && pc.isCustomInsertCallable();
    insertResultCheckStyles[jk]=pc.getCustomSQLInsertCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLInsert[jk],insertCallable[jk]) : pc.getCustomSQLInsertCheckStyle();
    customSQLUpdate[jk]=pc.getCustomSQLUpdate();
    updateCallable[jk]=customSQLUpdate[jk] != null && pc.isCustomUpdateCallable();
    updateResultCheckStyles[jk]=pc.getCustomSQLUpdateCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLUpdate[jk],updateCallable[jk]) : pc.getCustomSQLUpdateCheckStyle();
    customSQLDelete[jk]=pc.getCustomSQLDelete();
    deleteCallable[jk]=customSQLDelete[jk] != null && pc.isCustomDeleteCallable();
    deleteResultCheckStyles[jk]=pc.getCustomSQLDeleteCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLDelete[jk],deleteCallable[jk]) : pc.getCustomSQLDeleteCheckStyle();
    jk--;
    pc=pc.getSuperclass();
  }
  if (jk != -1) {
    throw new AssertionFailure("Tablespan does not match height of joined-subclass hiearchy.");
  }
  joinItr=persistentClass.getJoinClosureIterator();
  int j=coreTableSpan;
  while (joinItr.hasNext()) {
    Join join=(Join)joinItr.next();
    customSQLInsert[j]=join.getCustomSQLInsert();
    insertCallable[j]=customSQLInsert[j] != null && join.isCustomInsertCallable();
    insertResultCheckStyles[j]=join.getCustomSQLInsertCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLInsert[j],insertCallable[j]) : join.getCustomSQLInsertCheckStyle();
    customSQLUpdate[j]=join.getCustomSQLUpdate();
    updateCallable[j]=customSQLUpdate[j] != null && join.isCustomUpdateCallable();
    updateResultCheckStyles[j]=join.getCustomSQLUpdateCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLUpdate[j],updateCallable[j]) : join.getCustomSQLUpdateCheckStyle();
    customSQLDelete[j]=join.getCustomSQLDelete();
    deleteCallable[j]=customSQLDelete[j] != null && join.isCustomDeleteCallable();
    deleteResultCheckStyles[j]=join.getCustomSQLDeleteCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(customSQLDelete[j],deleteCallable[j]) : join.getCustomSQLDeleteCheckStyle();
    j++;
  }
  int hydrateSpan=getPropertySpan();
  naturalOrderPropertyTableNumbers=new int[hydrateSpan];
  propertyTableNumbers=new int[hydrateSpan];
  Iterator iter=persistentClass.getPropertyClosureIterator();
  int i=0;
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    String tabname=prop.getValue().getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    propertyTableNumbers[i]=getTableId(tabname,this.tableNames);
    naturalOrderPropertyTableNumbers[i]=getTableId(tabname,naturalOrderTableNames);
    i++;
  }
  ArrayList columnTableNumbers=new ArrayList();
  ArrayList formulaTableNumbers=new ArrayList();
  ArrayList propTableNumbers=new ArrayList();
  iter=persistentClass.getSubclassPropertyClosureIterator();
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    Table tab=prop.getValue().getTable();
    String tabname=tab.getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName());
    Integer tabnum=getTableId(tabname,subclassTableNameClosure);
    propTableNumbers.add(tabnum);
    Iterator citer=prop.getColumnIterator();
    while (citer.hasNext()) {
      Selectable thing=(Selectable)citer.next();
      if (thing.isFormula()) {
        formulaTableNumbers.add(tabnum);
      }
 else {
        columnTableNumbers.add(tabnum);
      }
    }
  }
  subclassColumnTableNumberClosure=ArrayHelper.toIntArray(columnTableNumbers);
  subclassPropertyTableNumberClosure=ArrayHelper.toIntArray(propTableNumbers);
  subclassFormulaTableNumberClosure=ArrayHelper.toIntArray(formulaTableNumbers);
  int subclassSpan=persistentClass.getSubclassSpan() + 1;
  subclassClosure=new String[subclassSpan];
  subclassClosure[subclassSpan - 1]=getEntityName();
  if (persistentClass.isPolymorphic()) {
    subclassesByDiscriminatorValue.put(discriminatorValue,getEntityName());
    discriminatorValues=new String[subclassSpan];
    discriminatorValues[subclassSpan - 1]=discriminatorSQLString;
    notNullColumnTableNumbers=new int[subclassSpan];
    final int id=getTableId(persistentClass.getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName()),subclassTableNameClosure);
    notNullColumnTableNumbers[subclassSpan - 1]=id;
    notNullColumnNames=new String[subclassSpan];
    notNullColumnNames[subclassSpan - 1]=subclassTableKeyColumnClosure[id][0];
  }
 else {
    discriminatorValues=null;
    notNullColumnTableNumbers=null;
    notNullColumnNames=null;
  }
  iter=persistentClass.getSubclassIterator();
  int k=0;
  while (iter.hasNext()) {
    Subclass sc=(Subclass)iter.next();
    subclassClosure[k]=sc.getEntityName();
    try {
      if (persistentClass.isPolymorphic()) {
        final Object discriminatorValue;
        if (explicitDiscriminatorColumnName != null) {
          if (sc.isDiscriminatorValueNull()) {
            discriminatorValue=NULL_DISCRIMINATOR;
          }
 else           if (sc.isDiscriminatorValueNotNull()) {
            discriminatorValue=NOT_NULL_DISCRIMINATOR;
          }
 else {
            try {
              discriminatorValue=discriminatorType.stringToObject(sc.getDiscriminatorValue());
            }
 catch (            ClassCastException cce) {
              throw new MappingException("Illegal discriminator type: " + discriminatorType.getName());
            }
catch (            Exception e) {
              throw new MappingException("Could not format discriminator value to SQL string",e);
            }
          }
        }
 else {
          discriminatorValue=sc.getSubclassId();
        }
        subclassesByDiscriminatorValue.put(discriminatorValue,sc.getEntityName());
        discriminatorValues[k]=discriminatorValue.toString();
        int id=getTableId(sc.getTable().getQualifiedName(factory.getDialect(),factory.getSettings().getDefaultCatalogName(),factory.getSettings().getDefaultSchemaName()),subclassTableNameClosure);
        notNullColumnTableNumbers[k]=id;
        notNullColumnNames[k]=subclassTableKeyColumnClosure[id][0];
      }
    }
 catch (    Exception e) {
      throw new MappingException("Error parsing discriminator value",e);
    }
    k++;
  }
  subclassNamesBySubclassTable=buildSubclassNamesBySubclassTableMapping(persistentClass,factory);
  initLockers();
  initSubclassPropertyAliasesMap(persistentClass);
  postConstruct(creationContext.getMetadata());
}
