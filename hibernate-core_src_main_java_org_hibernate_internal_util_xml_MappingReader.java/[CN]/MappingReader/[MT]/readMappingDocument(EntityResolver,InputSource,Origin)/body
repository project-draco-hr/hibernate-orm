{
  ErrorLogger errorHandler=new ErrorLogger();
  SAXReader saxReader=new SAXReader(new DOMDocumentFactory());
  saxReader.setEntityResolver(entityResolver);
  saxReader.setErrorHandler(errorHandler);
  saxReader.setMergeAdjacentText(true);
  Document documentTree;
  saxReader.setValidation(true);
  try {
    documentTree=saxReader.read(source);
  }
 catch (  DocumentException e) {
    throw new InvalidMappingException("Unable to read XML",origin.getType(),origin.getName(),e);
  }
  Element rootElement=documentTree.getRootElement();
  if (rootElement == null) {
    throw new InvalidMappingException("No root element",origin.getType(),origin.getName());
  }
  if ("entity-mappings".equals(rootElement.getName())) {
    final String explicitVersion=rootElement.attributeValue("version");
    final String xsdVersionString=explicitVersion == null ? ASSUMED_ORM_XSD_VERSION : explicitVersion;
    final SupportedOrmXsdVersion xsdVersion=SupportedOrmXsdVersion.parse(xsdVersionString,origin);
    final Schema schema=xsdVersion.getSchema();
    try {
      schema.newValidator().validate(new DOMSource((org.w3c.dom.Document)documentTree));
    }
 catch (    SAXException e) {
      throw new InvalidMappingException("Validation problem",origin.getType(),origin.getName(),e);
    }
catch (    IOException e) {
      throw new InvalidMappingException("Validation problem",origin.getType(),origin.getName(),e);
    }
  }
 else {
    if (errorHandler.hasErrors()) {
      errorHandler.logErrors();
      errorHandler.reset();
      throw new InvalidMappingException("Error validating hibernate-mapping against DTD; see logs for details",origin.getType(),origin.getName());
    }
  }
  return new XmlDocumentImpl(documentTree,origin);
}
