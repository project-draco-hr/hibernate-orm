{
  Lock lock=new Lock();
  lock.setName("name");
  EntityManager em=getOrCreateEntityManager();
  final EntityManager em2=createIsolatedEntityManager();
  em.getTransaction().begin();
  em.persist(lock);
  em.getTransaction().commit();
  em.getTransaction().begin();
  lock=em.getReference(Lock.class,lock.getId());
  final Integer id=lock.getId();
  em.lock(lock,LockModeType.READ);
  em.lock(lock,LockModeType.OPTIMISTIC_FORCE_INCREMENT);
  lock.setName("surname");
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      try {
        em2.getTransaction().begin();
        Lock lock2=em2.getReference(Lock.class,id);
        lock2.setName("renamed");
      }
  finally {
        em2.getTransaction().commit();
        latch.countDown();
        em2.close();
      }
    }
  }
);
  t.setDaemon(true);
  t.setName("testUpgradeReadLockToOptimisticForceIncrement tx2");
  t.start();
  log.info("testUpgradeReadLockToOptimisticForceIncrement:  wait on BG thread");
  boolean latchSet=latch.await(10,TimeUnit.SECONDS);
  assertTrue("background test thread finished (lock timeout is broken)",latchSet);
  try {
    em.getTransaction().commit();
  }
 catch (  Throwable expectedToFail) {
    while (expectedToFail != null && !(expectedToFail instanceof javax.persistence.OptimisticLockException)) {
      expectedToFail=expectedToFail.getCause();
    }
    assertTrue("upgrade to OPTIMISTIC_FORCE_INCREMENT is expected to fail at end of transaction1 since tranaction2 already updated the entity",expectedToFail instanceof javax.persistence.OptimisticLockException);
  }
  em.close();
}
