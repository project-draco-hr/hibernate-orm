{
  Settings settings=new Settings();
  String sessionFactoryName=props.getProperty(Environment.SESSION_FACTORY_NAME);
  settings.setSessionFactoryName(sessionFactoryName);
  ConnectionProvider connections=createConnectionProvider(props);
  settings.setConnectionProvider(connections);
  boolean metaSupportsScrollable=false;
  boolean metaSupportsGetGeneratedKeys=false;
  boolean metaSupportsBatchUpdates=false;
  boolean metaReportsDDLCausesTxnCommit=false;
  boolean metaReportsDDLInTxnSupported=true;
  Dialect dialect=null;
  boolean useJdbcMetadata=PropertiesHelper.getBoolean("hibernate.temp.use_jdbc_metadata_defaults",props,true);
  if (useJdbcMetadata) {
    try {
      Connection conn=connections.getConnection();
      try {
        DatabaseMetaData meta=conn.getMetaData();
        log.info("Database ->\n" + "       name : " + meta.getDatabaseProductName() + '\n'+ "    version : "+ meta.getDatabaseProductVersion()+ '\n'+ "      major : "+ meta.getDatabaseMajorVersion()+ '\n'+ "      minor : "+ meta.getDatabaseMinorVersion());
        log.info("Driver ->\n" + "       name : " + meta.getDriverName() + '\n'+ "    version : "+ meta.getDriverVersion()+ '\n'+ "      major : "+ meta.getDriverMajorVersion()+ '\n'+ "      minor : "+ meta.getDriverMinorVersion());
        dialect=DialectFactory.buildDialect(props,conn);
        metaSupportsScrollable=meta.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
        metaSupportsBatchUpdates=meta.supportsBatchUpdates();
        metaReportsDDLCausesTxnCommit=meta.dataDefinitionCausesTransactionCommit();
        metaReportsDDLInTxnSupported=!meta.dataDefinitionIgnoredInTransactions();
        metaSupportsGetGeneratedKeys=meta.supportsGetGeneratedKeys();
      }
 catch (      SQLException sqle) {
        log.warn("Could not obtain connection metadata",sqle);
      }
 finally {
        connections.closeConnection(conn);
      }
    }
 catch (    SQLException sqle) {
      log.warn("Could not obtain connection to query metadata",sqle);
      dialect=DialectFactory.buildDialect(props);
    }
catch (    UnsupportedOperationException uoe) {
      dialect=DialectFactory.buildDialect(props);
    }
  }
 else {
    dialect=DialectFactory.buildDialect(props);
  }
  settings.setDataDefinitionImplicitCommit(metaReportsDDLCausesTxnCommit);
  settings.setDataDefinitionInTransactionSupported(metaReportsDDLInTxnSupported);
  settings.setDialect(dialect);
  settings.setJdbcSupport(new JdbcSupport());
  final Properties properties=new Properties();
  properties.putAll(dialect.getDefaultProperties());
  properties.putAll(props);
  TransactionFactory transactionFactory=createTransactionFactory(properties);
  settings.setTransactionFactory(transactionFactory);
  settings.setTransactionManagerLookup(createTransactionManagerLookup(properties));
  boolean flushBeforeCompletion=PropertiesHelper.getBoolean(Environment.FLUSH_BEFORE_COMPLETION,properties);
  log.info("Automatic flush during beforeCompletion(): " + enabledDisabled(flushBeforeCompletion));
  settings.setFlushBeforeCompletionEnabled(flushBeforeCompletion);
  boolean autoCloseSession=PropertiesHelper.getBoolean(Environment.AUTO_CLOSE_SESSION,properties);
  log.info("Automatic session close at end of transaction: " + enabledDisabled(autoCloseSession));
  settings.setAutoCloseSessionEnabled(autoCloseSession);
  int batchSize=PropertiesHelper.getInt(Environment.STATEMENT_BATCH_SIZE,properties,0);
  if (!metaSupportsBatchUpdates)   batchSize=0;
  if (batchSize > 0)   log.info("JDBC batch size: " + batchSize);
  settings.setJdbcBatchSize(batchSize);
  boolean jdbcBatchVersionedData=PropertiesHelper.getBoolean(Environment.BATCH_VERSIONED_DATA,properties,false);
  if (batchSize > 0)   log.info("JDBC batch updates for versioned data: " + enabledDisabled(jdbcBatchVersionedData));
  settings.setJdbcBatchVersionedData(jdbcBatchVersionedData);
  settings.setBatcherFactory(createBatcherFactory(properties,batchSize));
  boolean useScrollableResultSets=PropertiesHelper.getBoolean(Environment.USE_SCROLLABLE_RESULTSET,properties,metaSupportsScrollable);
  log.info("Scrollable result sets: " + enabledDisabled(useScrollableResultSets));
  settings.setScrollableResultSetsEnabled(useScrollableResultSets);
  boolean wrapResultSets=PropertiesHelper.getBoolean(Environment.WRAP_RESULT_SETS,properties,false);
  log.debug("Wrap result sets: " + enabledDisabled(wrapResultSets));
  settings.setWrapResultSetsEnabled(wrapResultSets);
  boolean useGetGeneratedKeys=PropertiesHelper.getBoolean(Environment.USE_GET_GENERATED_KEYS,properties,metaSupportsGetGeneratedKeys);
  log.info("JDBC3 getGeneratedKeys(): " + enabledDisabled(useGetGeneratedKeys));
  settings.setGetGeneratedKeysEnabled(useGetGeneratedKeys);
  Integer statementFetchSize=PropertiesHelper.getInteger(Environment.STATEMENT_FETCH_SIZE,properties);
  if (statementFetchSize != null)   log.info("JDBC result set fetch size: " + statementFetchSize);
  settings.setJdbcFetchSize(statementFetchSize);
  String releaseModeName=PropertiesHelper.getString(Environment.RELEASE_CONNECTIONS,properties,"auto");
  log.info("Connection release mode: " + releaseModeName);
  ConnectionReleaseMode releaseMode;
  if ("auto".equals(releaseModeName)) {
    releaseMode=transactionFactory.getDefaultReleaseMode();
  }
 else {
    releaseMode=ConnectionReleaseMode.parse(releaseModeName);
    if (releaseMode == ConnectionReleaseMode.AFTER_STATEMENT && !connections.supportsAggressiveRelease()) {
      log.warn("Overriding release mode as connection provider does not support 'after_statement'");
      releaseMode=ConnectionReleaseMode.AFTER_TRANSACTION;
    }
  }
  settings.setConnectionReleaseMode(releaseMode);
  String defaultSchema=properties.getProperty(Environment.DEFAULT_SCHEMA);
  String defaultCatalog=properties.getProperty(Environment.DEFAULT_CATALOG);
  if (defaultSchema != null)   log.info("Default schema: " + defaultSchema);
  if (defaultCatalog != null)   log.info("Default catalog: " + defaultCatalog);
  settings.setDefaultSchemaName(defaultSchema);
  settings.setDefaultCatalogName(defaultCatalog);
  Integer maxFetchDepth=PropertiesHelper.getInteger(Environment.MAX_FETCH_DEPTH,properties);
  if (maxFetchDepth != null)   log.info("Maximum outer join fetch depth: " + maxFetchDepth);
  settings.setMaximumFetchDepth(maxFetchDepth);
  int batchFetchSize=PropertiesHelper.getInt(Environment.DEFAULT_BATCH_FETCH_SIZE,properties,1);
  log.info("Default batch fetch size: " + batchFetchSize);
  settings.setDefaultBatchFetchSize(batchFetchSize);
  boolean comments=PropertiesHelper.getBoolean(Environment.USE_SQL_COMMENTS,properties);
  log.info("Generate SQL with comments: " + enabledDisabled(comments));
  settings.setCommentsEnabled(comments);
  boolean orderUpdates=PropertiesHelper.getBoolean(Environment.ORDER_UPDATES,properties);
  log.info("Order SQL updates by primary key: " + enabledDisabled(orderUpdates));
  settings.setOrderUpdatesEnabled(orderUpdates);
  boolean orderInserts=PropertiesHelper.getBoolean(Environment.ORDER_INSERTS,properties);
  log.info("Order SQL inserts for batching: " + enabledDisabled(orderInserts));
  settings.setOrderInsertsEnabled(orderInserts);
  settings.setQueryTranslatorFactory(createQueryTranslatorFactory(properties));
  Map querySubstitutions=PropertiesHelper.toMap(Environment.QUERY_SUBSTITUTIONS," ,=;:\n\t\r\f",properties);
  log.info("Query language substitutions: " + querySubstitutions);
  settings.setQuerySubstitutions(querySubstitutions);
  boolean jpaqlCompliance=PropertiesHelper.getBoolean(Environment.JPAQL_STRICT_COMPLIANCE,properties,false);
  settings.setStrictJPAQLCompliance(jpaqlCompliance);
  log.info("JPA-QL strict compliance: " + enabledDisabled(jpaqlCompliance));
  boolean useSecondLevelCache=PropertiesHelper.getBoolean(Environment.USE_SECOND_LEVEL_CACHE,properties,true);
  log.info("Second-level cache: " + enabledDisabled(useSecondLevelCache));
  settings.setSecondLevelCacheEnabled(useSecondLevelCache);
  boolean useQueryCache=PropertiesHelper.getBoolean(Environment.USE_QUERY_CACHE,properties);
  log.info("Query cache: " + enabledDisabled(useQueryCache));
  settings.setQueryCacheEnabled(useQueryCache);
  settings.setRegionFactory(createRegionFactory(properties,(useSecondLevelCache || useQueryCache)));
  boolean useMinimalPuts=PropertiesHelper.getBoolean(Environment.USE_MINIMAL_PUTS,properties,settings.getRegionFactory().isMinimalPutsEnabledByDefault());
  log.info("Optimize cache for minimal puts: " + enabledDisabled(useMinimalPuts));
  settings.setMinimalPutsEnabled(useMinimalPuts);
  String prefix=properties.getProperty(Environment.CACHE_REGION_PREFIX);
  if (StringHelper.isEmpty(prefix))   prefix=null;
  if (prefix != null)   log.info("Cache region prefix: " + prefix);
  settings.setCacheRegionPrefix(prefix);
  boolean useStructuredCacheEntries=PropertiesHelper.getBoolean(Environment.USE_STRUCTURED_CACHE,properties,false);
  log.info("Structured second-level cache entries: " + enabledDisabled(useStructuredCacheEntries));
  settings.setStructuredCacheEntriesEnabled(useStructuredCacheEntries);
  if (useQueryCache)   settings.setQueryCacheFactory(createQueryCacheFactory(properties));
  SQLExceptionConverter sqlExceptionConverter;
  try {
    sqlExceptionConverter=SQLExceptionConverterFactory.buildSQLExceptionConverter(dialect,properties);
  }
 catch (  HibernateException e) {
    log.warn("Error building SQLExceptionConverter; using minimal converter");
    sqlExceptionConverter=SQLExceptionConverterFactory.buildMinimalSQLExceptionConverter();
  }
  settings.setSQLExceptionConverter(sqlExceptionConverter);
  boolean showSql=PropertiesHelper.getBoolean(Environment.SHOW_SQL,properties);
  if (showSql)   log.info("Echoing all SQL to stdout");
  boolean formatSql=PropertiesHelper.getBoolean(Environment.FORMAT_SQL,properties);
  settings.setSqlStatementLogger(new SQLStatementLogger(showSql,formatSql));
  boolean useStatistics=PropertiesHelper.getBoolean(Environment.GENERATE_STATISTICS,properties);
  log.info("Statistics: " + enabledDisabled(useStatistics));
  settings.setStatisticsEnabled(useStatistics);
  boolean useIdentifierRollback=PropertiesHelper.getBoolean(Environment.USE_IDENTIFIER_ROLLBACK,properties);
  log.info("Deleted entity synthetic identifier rollback: " + enabledDisabled(useIdentifierRollback));
  settings.setIdentifierRollbackEnabled(useIdentifierRollback);
  String autoSchemaExport=properties.getProperty(Environment.HBM2DDL_AUTO);
  if ("validate".equals(autoSchemaExport))   settings.setAutoValidateSchema(true);
  if ("update".equals(autoSchemaExport))   settings.setAutoUpdateSchema(true);
  if ("create".equals(autoSchemaExport))   settings.setAutoCreateSchema(true);
  if ("create-drop".equals(autoSchemaExport)) {
    settings.setAutoCreateSchema(true);
    settings.setAutoDropSchema(true);
  }
  settings.setImportFiles(properties.getProperty(Environment.HBM2DDL_IMPORT_FILES));
  EntityMode defaultEntityMode=EntityMode.parse(properties.getProperty(Environment.DEFAULT_ENTITY_MODE));
  log.info("Default entity-mode: " + defaultEntityMode);
  settings.setDefaultEntityMode(defaultEntityMode);
  boolean namedQueryChecking=PropertiesHelper.getBoolean(Environment.QUERY_STARTUP_CHECKING,properties,true);
  log.info("Named query checking : " + enabledDisabled(namedQueryChecking));
  settings.setNamedQueryStartupCheckingEnabled(namedQueryChecking);
  boolean checkNullability=PropertiesHelper.getBoolean(Environment.CHECK_NULLABILITY,properties,true);
  log.info("Check Nullability in Core (should be disabled when Bean Validation is on): " + enabledDisabled(checkNullability));
  settings.setCheckNullability(checkNullability);
  return settings;
}
