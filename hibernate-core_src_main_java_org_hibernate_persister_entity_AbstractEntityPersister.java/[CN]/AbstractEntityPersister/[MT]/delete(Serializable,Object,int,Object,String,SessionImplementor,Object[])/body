{
  if (isInverseTable(j)) {
    return;
  }
  final boolean useVersion=j == 0 && isVersioned();
  final boolean callable=isDeleteCallable(j);
  final Expectation expectation=Expectations.appropriateExpectation(deleteResultCheckStyles[j]);
  final boolean useBatch=j == 0 && isBatchable() && expectation.canBeBatched();
  if (useBatch && deleteBatchKey == null) {
    deleteBatchKey=new BasicBatchKey(getEntityName() + "#DELETE",expectation);
  }
  if (log.isTraceEnabled()) {
    log.trace("Deleting entity: " + MessageHelper.infoString(this,id,getFactory()));
    if (useVersion) {
      log.trace("Version: " + version);
    }
  }
  if (isTableCascadeDeleteEnabled(j)) {
    if (log.isTraceEnabled()) {
      log.trace("delete handled by foreign key constraint: " + getTableName(j));
    }
    return;
  }
  try {
    PreparedStatement delete;
    int index=1;
    if (useBatch) {
      delete=session.getTransactionCoordinator().getJdbcCoordinator().getBatch(deleteBatchKey).getBatchStatement(sql,callable);
    }
 else {
      delete=session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
    }
    try {
      index+=expectation.prepare(delete);
      getIdentifierType().nullSafeSet(delete,id,index,session);
      index+=getIdentifierColumnSpan();
      if (useVersion) {
        getVersionType().nullSafeSet(delete,version,index,session);
      }
 else       if (entityMetamodel.getOptimisticLockMode() > Versioning.OPTIMISTIC_LOCK_VERSION && loadedState != null) {
        boolean[] versionability=getPropertyVersionability();
        Type[] types=getPropertyTypes();
        for (int i=0; i < entityMetamodel.getPropertySpan(); i++) {
          if (isPropertyOfTable(i,j) && versionability[i]) {
            boolean[] settable=types[i].toColumnNullness(loadedState[i],getFactory());
            types[i].nullSafeSet(delete,loadedState[i],index,settable,session);
            index+=ArrayHelper.countTrue(settable);
          }
        }
      }
      if (useBatch) {
        session.getTransactionCoordinator().getJdbcCoordinator().getBatch(deleteBatchKey).addToBatch();
      }
 else {
        check(delete.executeUpdate(),id,j,expectation,delete);
      }
    }
 catch (    SQLException sqle) {
      if (useBatch) {
        session.getTransactionCoordinator().getJdbcCoordinator().abortBatch();
      }
      throw sqle;
    }
 finally {
      if (!useBatch) {
        delete.close();
      }
    }
  }
 catch (  SQLException sqle) {
    throw getFactory().getSQLExceptionHelper().convert(sqle,"could not delete: " + MessageHelper.infoString(this,id,getFactory()),sql);
  }
}
