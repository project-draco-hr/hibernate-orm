{
  if (isInverseTable(j)) {
    return;
  }
  if (isNullableTable(j) && isAllNull(fields,j)) {
    return;
  }
  if (LOG.isTraceEnabled()) {
    LOG.insertingEntity(MessageHelper.infoString(this,id,getFactory()));
    if (j == 0 && isVersioned())     LOG.version(Versioning.getVersion(fields,this));
  }
  Expectation expectation=Expectations.appropriateExpectation(insertResultCheckStyles[j]);
  boolean callable=isInsertCallable(j);
  final boolean useBatch=j == 0 && expectation.canBeBatched();
  try {
    final PreparedStatement insert;
    if (useBatch) {
      insert=session.getJDBCContext().getConnectionManager().prepareBatchStatement(this,sql,callable);
    }
 else {
      insert=session.getJDBCContext().getConnectionManager().prepareStatement(sql,callable);
    }
    try {
      int index=1;
      index+=expectation.prepare(insert);
      dehydrate(id,fields,null,notNull,propertyColumnInsertable,j,insert,session,index);
      if (useBatch) {
        session.getJDBCContext().getConnectionManager().addToBatch(this,sql,expectation);
      }
 else {
        expectation.verifyOutcome(insert.executeUpdate(),insert,-1);
      }
    }
 catch (    SQLException sqle) {
      if (useBatch) {
        session.getJDBCContext().getConnectionManager().abortBatch();
      }
      throw sqle;
    }
 finally {
      if (!useBatch) {
        insert.close();
      }
    }
  }
 catch (  SQLException sqle) {
    throw getFactory().getSQLExceptionHelper().convert(sqle,"could not insert: " + MessageHelper.infoString(this),sql);
  }
}
