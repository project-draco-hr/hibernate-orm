{
  this.factory=factory;
  this.cacheAccessStrategy=cacheAccessStrategy;
  this.isLazyPropertiesCacheable=entityBinding.getCaching() == null ? false : entityBinding.getCaching().isCacheLazyProperties();
  this.cacheEntryStructure=factory.getSettings().isStructuredCacheEntriesEnabled() ? new StructuredCacheEntry(this) : new UnstructuredCacheEntry();
  this.entityMetamodel=new EntityMetamodel(entityBinding,factory);
  int batch=entityBinding.getBatchSize();
  if (batch == -1) {
    batch=factory.getSettings().getDefaultBatchFetchSize();
  }
  batchSize=batch;
  hasSubselectLoadableCollections=entityBinding.hasSubselectLoadableCollections();
  propertyMapping=new BasicEntityPropertyMapping(this);
  identifierColumnSpan=entityBinding.getEntityIdentifier().getValueBinding().getValuesSpan();
  rootTableKeyColumnNames=new String[identifierColumnSpan];
  rootTableKeyColumnReaders=new String[identifierColumnSpan];
  rootTableKeyColumnReaderTemplates=new String[identifierColumnSpan];
  identifierAliases=new String[identifierColumnSpan];
  rowIdName=entityBinding.getRowId();
  loaderName=entityBinding.getCustomLoaderName();
  int i=0;
  for (  org.hibernate.metamodel.relational.Column col : entityBinding.getBaseTable().getPrimaryKey().getColumns()) {
    rootTableKeyColumnNames[i]=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
    if (col.getReadFragment() == null) {
      rootTableKeyColumnReaders[i]=rootTableKeyColumnNames[i];
      rootTableKeyColumnReaderTemplates[i]=getTemplateFromColumn(col,factory);
    }
 else {
      rootTableKeyColumnReaders[i]=col.getReadFragment();
      rootTableKeyColumnReaderTemplates[i]=getTemplateFromString(col.getReadFragment(),factory);
    }
    identifierAliases[i]=col.getAlias(factory.getDialect());
    i++;
  }
  if (entityBinding.isVersioned()) {
    Iterator<SimpleValue> valueIterator=entityBinding.getVersioningValueBinding().getValues().iterator();
    SimpleValue versionValue=valueIterator.next();
    if (!(versionValue instanceof org.hibernate.metamodel.relational.Column) || valueIterator.hasNext()) {
      throw new MappingException("Version must be a single column value.");
    }
    org.hibernate.metamodel.relational.Column versionColumn=(org.hibernate.metamodel.relational.Column)versionValue;
    versionColumnName=versionColumn.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
  }
 else {
    versionColumnName=null;
  }
  sqlWhereString=StringHelper.isNotEmpty(entityBinding.getWhereFilter()) ? "( " + entityBinding.getWhereFilter() + ") " : null;
  sqlWhereStringTemplate=getTemplateFromString(sqlWhereString,factory);
  final boolean lazyAvailable=isInstrumented();
  int hydrateSpan=entityMetamodel.getPropertySpan();
  propertyColumnSpans=new int[hydrateSpan];
  propertySubclassNames=new String[hydrateSpan];
  propertyColumnAliases=new String[hydrateSpan][];
  propertyColumnNames=new String[hydrateSpan][];
  propertyColumnFormulaTemplates=new String[hydrateSpan][];
  propertyColumnReaderTemplates=new String[hydrateSpan][];
  propertyColumnWriters=new String[hydrateSpan][];
  propertyUniqueness=new boolean[hydrateSpan];
  propertySelectable=new boolean[hydrateSpan];
  propertyColumnUpdateable=new boolean[hydrateSpan][];
  propertyColumnInsertable=new boolean[hydrateSpan][];
  HashSet thisClassProperties=new HashSet();
  lazyProperties=new HashSet();
  ArrayList lazyNames=new ArrayList();
  ArrayList lazyNumbers=new ArrayList();
  ArrayList lazyTypes=new ArrayList();
  ArrayList lazyColAliases=new ArrayList();
  i=0;
  boolean foundFormula=false;
  for (  AttributeBinding prop : entityBinding.getAttributeBindingClosure()) {
    if (prop == entityBinding.getEntityIdentifier().getValueBinding()) {
      continue;
    }
    thisClassProperties.add(prop);
    int span=prop.getValuesSpan();
    propertyColumnSpans[i]=span;
    propertySubclassNames[i]=prop.getEntityBinding().getEntity().getName();
    String[] colNames=new String[span];
    String[] colAliases=new String[span];
    String[] colReaderTemplates=new String[span];
    String[] colWriters=new String[span];
    String[] formulaTemplates=new String[span];
    int k=0;
    for (    SimpleValue thing : prop.getValues()) {
      colAliases[k]=thing.getAlias(factory.getDialect());
      if (thing instanceof DerivedValue) {
        foundFormula=true;
        formulaTemplates[k]=getTemplateFromString(((DerivedValue)thing).getExpression(),factory);
      }
 else {
        org.hibernate.metamodel.relational.Column col=(org.hibernate.metamodel.relational.Column)thing;
        colNames[k]=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
        colReaderTemplates[k]=getTemplateFromColumn(col,factory);
        colWriters[k]=col.getWriteFragment() == null ? "?" : col.getWriteFragment();
      }
      k++;
    }
    propertyColumnNames[i]=colNames;
    propertyColumnFormulaTemplates[i]=formulaTemplates;
    propertyColumnReaderTemplates[i]=colReaderTemplates;
    propertyColumnWriters[i]=colWriters;
    propertyColumnAliases[i]=colAliases;
    if (lazyAvailable && prop.isLazy()) {
      lazyProperties.add(prop.getAttribute().getName());
      lazyNames.add(prop.getAttribute().getName());
      lazyNumbers.add(i);
      lazyTypes.add(prop.getHibernateTypeDescriptor().getResolvedTypeMapping());
      lazyColAliases.add(colAliases);
    }
    propertyColumnUpdateable[i]=prop.getColumnUpdateability();
    propertyColumnInsertable[i]=prop.getColumnInsertability();
    propertySelectable[i]=true;
    propertyUniqueness[i]=prop.isAlternateUniqueKey();
    i++;
  }
  hasFormulaProperties=foundFormula;
  lazyPropertyColumnAliases=ArrayHelper.to2DStringArray(lazyColAliases);
  lazyPropertyNames=ArrayHelper.toStringArray(lazyNames);
  lazyPropertyNumbers=ArrayHelper.toIntArray(lazyNumbers);
  lazyPropertyTypes=ArrayHelper.toTypeArray(lazyTypes);
  List<String> columns=new ArrayList<String>();
  List<Boolean> columnsLazy=new ArrayList<Boolean>();
  List<String> columnReaderTemplates=new ArrayList<String>();
  List<String> aliases=new ArrayList<String>();
  List<String> formulas=new ArrayList<String>();
  List<String> formulaAliases=new ArrayList<String>();
  List<String> formulaTemplates=new ArrayList<String>();
  List<Boolean> formulasLazy=new ArrayList<Boolean>();
  List<Type> types=new ArrayList<Type>();
  List<String> names=new ArrayList<String>();
  List<String> classes=new ArrayList<String>();
  List<String[]> templates=new ArrayList<String[]>();
  List<String[]> propColumns=new ArrayList<String[]>();
  List<String[]> propColumnReaders=new ArrayList<String[]>();
  List<String[]> propColumnReaderTemplates=new ArrayList<String[]>();
  List<FetchMode> joinedFetchesList=new ArrayList<FetchMode>();
  List<CascadeStyle> cascades=new ArrayList<CascadeStyle>();
  List<Boolean> definedBySubclass=new ArrayList<Boolean>();
  List<int[]> propColumnNumbers=new ArrayList<int[]>();
  List<int[]> propFormulaNumbers=new ArrayList<int[]>();
  List<Boolean> columnSelectables=new ArrayList<Boolean>();
  List<Boolean> propNullables=new ArrayList<Boolean>();
  for (  AttributeBinding prop : entityBinding.getAttributeBindingClosure()) {
    if (prop == entityBinding.getEntityIdentifier().getValueBinding()) {
      continue;
    }
    names.add(prop.getAttribute().getName());
    classes.add(prop.getEntityBinding().getEntity().getName());
    boolean isDefinedBySubclass=!thisClassProperties.contains(prop);
    definedBySubclass.add(isDefinedBySubclass);
    propNullables.add(prop.isNullable() || isDefinedBySubclass);
    types.add(prop.getHibernateTypeDescriptor().getResolvedTypeMapping());
    String[] cols=new String[prop.getValuesSpan()];
    String[] readers=new String[prop.getValuesSpan()];
    String[] readerTemplates=new String[prop.getValuesSpan()];
    String[] forms=new String[prop.getValuesSpan()];
    int[] colnos=new int[prop.getValuesSpan()];
    int[] formnos=new int[prop.getValuesSpan()];
    int l=0;
    Boolean lazy=prop.isLazy() && lazyAvailable;
    for (    SimpleValue thing : prop.getValues()) {
      if (DerivedValue.class.isInstance(thing)) {
        DerivedValue derivedValue=DerivedValue.class.cast(thing);
        String template=getTemplateFromString(derivedValue.getExpression(),factory);
        formnos[l]=formulaTemplates.size();
        colnos[l]=-1;
        formulaTemplates.add(template);
        forms[l]=template;
        formulas.add(derivedValue.getExpression());
        formulaAliases.add(derivedValue.getAlias(factory.getDialect()));
        formulasLazy.add(lazy);
      }
 else       if (org.hibernate.metamodel.relational.Column.class.isInstance(thing)) {
        org.hibernate.metamodel.relational.Column col=org.hibernate.metamodel.relational.Column.class.cast(thing);
        String colName=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
        colnos[l]=columns.size();
        formnos[l]=-1;
        columns.add(colName);
        cols[l]=colName;
        aliases.add(thing.getAlias(factory.getDialect()));
        columnsLazy.add(lazy);
        columnSelectables.add(prop.isSimpleValue());
        readers[l]=col.getReadFragment() == null ? col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect()) : col.getReadFragment();
        String readerTemplate=getTemplateFromColumn(col,factory);
        readerTemplates[l]=readerTemplate;
        columnReaderTemplates.add(readerTemplate);
      }
      l++;
    }
    propColumns.add(cols);
    propColumnReaders.add(readers);
    propColumnReaderTemplates.add(readerTemplates);
    templates.add(forms);
    propColumnNumbers.add(colnos);
    propFormulaNumbers.add(formnos);
    joinedFetchesList.add(FetchMode.DEFAULT);
    cascades.add(CascadeStyle.NONE);
  }
  subclassColumnClosure=ArrayHelper.toStringArray(columns);
  subclassColumnAliasClosure=ArrayHelper.toStringArray(aliases);
  subclassColumnLazyClosure=ArrayHelper.toBooleanArray(columnsLazy);
  subclassColumnSelectableClosure=ArrayHelper.toBooleanArray(columnSelectables);
  subclassColumnReaderTemplateClosure=ArrayHelper.toStringArray(columnReaderTemplates);
  subclassFormulaClosure=ArrayHelper.toStringArray(formulas);
  subclassFormulaTemplateClosure=ArrayHelper.toStringArray(formulaTemplates);
  subclassFormulaAliasClosure=ArrayHelper.toStringArray(formulaAliases);
  subclassFormulaLazyClosure=ArrayHelper.toBooleanArray(formulasLazy);
  subclassPropertyNameClosure=ArrayHelper.toStringArray(names);
  subclassPropertySubclassNameClosure=ArrayHelper.toStringArray(classes);
  subclassPropertyTypeClosure=ArrayHelper.toTypeArray(types);
  subclassPropertyNullabilityClosure=ArrayHelper.toBooleanArray(propNullables);
  subclassPropertyFormulaTemplateClosure=ArrayHelper.to2DStringArray(templates);
  subclassPropertyColumnNameClosure=ArrayHelper.to2DStringArray(propColumns);
  subclassPropertyColumnReaderClosure=ArrayHelper.to2DStringArray(propColumnReaders);
  subclassPropertyColumnReaderTemplateClosure=ArrayHelper.to2DStringArray(propColumnReaderTemplates);
  subclassPropertyColumnNumberClosure=ArrayHelper.to2DIntArray(propColumnNumbers);
  subclassPropertyFormulaNumberClosure=ArrayHelper.to2DIntArray(propFormulaNumbers);
  subclassPropertyCascadeStyleClosure=cascades.toArray(new CascadeStyle[cascades.size()]);
  subclassPropertyFetchModeClosure=joinedFetchesList.toArray(new FetchMode[joinedFetchesList.size()]);
  propertyDefinedOnSubclass=ArrayHelper.toBooleanArray(definedBySubclass);
  Map<String,String> filterDefaultConditionsByName=new HashMap<String,String>();
  for (  FilterDefinition filterDefinition : entityBinding.getFilterDefinitions()) {
    filterDefaultConditionsByName.put(filterDefinition.getFilterName(),filterDefinition.getDefaultFilterCondition());
  }
  filterHelper=new FilterHelper(filterDefaultConditionsByName,factory.getDialect(),factory.getSqlFunctionRegistry());
  temporaryIdTableName=null;
  temporaryIdTableDDL=null;
}
