{
  this.factory=factory;
  this.cacheAccessStrategy=cacheAccessStrategy;
  this.naturalIdRegionAccessStrategy=naturalIdRegionAccessStrategy;
  this.isLazyPropertiesCacheable=entityBinding.getHierarchyDetails().getCaching() == null ? false : entityBinding.getHierarchyDetails().getCaching().isCacheLazyProperties();
  this.cacheEntryStructure=factory.getSettings().isStructuredCacheEntriesEnabled() ? new StructuredCacheEntry(this) : new UnstructuredCacheEntry();
  this.entityMetamodel=new EntityMetamodel(entityBinding,factory);
  this.entityTuplizer=this.entityMetamodel.getTuplizer();
  int batch=entityBinding.getBatchSize();
  if (batch == -1) {
    batch=factory.getSettings().getDefaultBatchFetchSize();
  }
  batchSize=batch;
  hasSubselectLoadableCollections=entityBinding.hasSubselectLoadableCollections();
  propertyMapping=new BasicEntityPropertyMapping(this);
  identifierColumnSpan=entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding().getSimpleValueSpan();
  rootTableKeyColumnNames=new String[identifierColumnSpan];
  rootTableKeyColumnReaders=new String[identifierColumnSpan];
  rootTableKeyColumnReaderTemplates=new String[identifierColumnSpan];
  identifierAliases=new String[identifierColumnSpan];
  rowIdName=entityBinding.getRowId();
  loaderName=entityBinding.getCustomLoaderName();
  int i=0;
  for (  org.hibernate.metamodel.relational.Column col : entityBinding.getPrimaryTable().getPrimaryKey().getColumns()) {
    rootTableKeyColumnNames[i]=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
    if (col.getReadFragment() == null) {
      rootTableKeyColumnReaders[i]=rootTableKeyColumnNames[i];
      rootTableKeyColumnReaderTemplates[i]=getTemplateFromColumn(col,factory);
    }
 else {
      rootTableKeyColumnReaders[i]=col.getReadFragment();
      rootTableKeyColumnReaderTemplates[i]=getTemplateFromString(col.getReadFragment(),factory);
    }
    identifierAliases[i]=col.getAlias(factory.getDialect());
    i++;
  }
  if (entityBinding.isVersioned()) {
    final Value versioningValue=entityBinding.getHierarchyDetails().getVersioningAttributeBinding().getValue();
    if (!org.hibernate.metamodel.relational.Column.class.isInstance(versioningValue)) {
      throw new AssertionFailure("Bad versioning attribute binding : " + versioningValue);
    }
    org.hibernate.metamodel.relational.Column versionColumn=org.hibernate.metamodel.relational.Column.class.cast(versioningValue);
    versionColumnName=versionColumn.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
  }
 else {
    versionColumnName=null;
  }
  sqlWhereString=StringHelper.isNotEmpty(entityBinding.getWhereFilter()) ? "( " + entityBinding.getWhereFilter() + ") " : null;
  sqlWhereStringTemplate=getTemplateFromString(sqlWhereString,factory);
  final boolean lazyAvailable=isInstrumented();
  int hydrateSpan=entityMetamodel.getPropertySpan();
  propertyColumnSpans=new int[hydrateSpan];
  propertySubclassNames=new String[hydrateSpan];
  propertyColumnAliases=new String[hydrateSpan][];
  propertyColumnNames=new String[hydrateSpan][];
  propertyColumnFormulaTemplates=new String[hydrateSpan][];
  propertyColumnReaderTemplates=new String[hydrateSpan][];
  propertyColumnWriters=new String[hydrateSpan][];
  propertyUniqueness=new boolean[hydrateSpan];
  propertySelectable=new boolean[hydrateSpan];
  propertyColumnUpdateable=new boolean[hydrateSpan][];
  propertyColumnInsertable=new boolean[hydrateSpan][];
  HashSet thisClassProperties=new HashSet();
  lazyProperties=new HashSet();
  ArrayList lazyNames=new ArrayList();
  ArrayList lazyNumbers=new ArrayList();
  ArrayList lazyTypes=new ArrayList();
  ArrayList lazyColAliases=new ArrayList();
  i=0;
  boolean foundFormula=false;
  for (  AttributeBinding attributeBinding : entityBinding.getAttributeBindingClosure()) {
    if (attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding()) {
      continue;
    }
    if (!attributeBinding.getAttribute().isSingular()) {
      continue;
    }
    final SingularAttributeBinding singularAttributeBinding=(SingularAttributeBinding)attributeBinding;
    thisClassProperties.add(singularAttributeBinding);
    propertySubclassNames[i]=((EntityBinding)singularAttributeBinding.getContainer()).getEntity().getName();
    int span=singularAttributeBinding.getSimpleValueSpan();
    propertyColumnSpans[i]=span;
    String[] colNames=new String[span];
    String[] colAliases=new String[span];
    String[] colReaderTemplates=new String[span];
    String[] colWriters=new String[span];
    String[] formulaTemplates=new String[span];
    boolean[] propertyColumnInsertability=new boolean[span];
    boolean[] propertyColumnUpdatability=new boolean[span];
    int k=0;
    for (    SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings()) {
      colAliases[k]=valueBinding.getSimpleValue().getAlias(factory.getDialect());
      if (valueBinding.isDerived()) {
        foundFormula=true;
        formulaTemplates[k]=getTemplateFromString(((DerivedValue)valueBinding.getSimpleValue()).getExpression(),factory);
      }
 else {
        org.hibernate.metamodel.relational.Column col=(org.hibernate.metamodel.relational.Column)valueBinding.getSimpleValue();
        colNames[k]=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
        colReaderTemplates[k]=getTemplateFromColumn(col,factory);
        colWriters[k]=col.getWriteFragment() == null ? "?" : col.getWriteFragment();
      }
      propertyColumnInsertability[k]=valueBinding.isIncludeInInsert();
      propertyColumnUpdatability[k]=valueBinding.isIncludeInUpdate();
      k++;
    }
    propertyColumnNames[i]=colNames;
    propertyColumnFormulaTemplates[i]=formulaTemplates;
    propertyColumnReaderTemplates[i]=colReaderTemplates;
    propertyColumnWriters[i]=colWriters;
    propertyColumnAliases[i]=colAliases;
    propertyColumnUpdateable[i]=propertyColumnUpdatability;
    propertyColumnInsertable[i]=propertyColumnInsertability;
    if (lazyAvailable && singularAttributeBinding.isLazy()) {
      lazyProperties.add(singularAttributeBinding.getAttribute().getName());
      lazyNames.add(singularAttributeBinding.getAttribute().getName());
      lazyNumbers.add(i);
      lazyTypes.add(singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping());
      lazyColAliases.add(colAliases);
    }
    propertySelectable[i]=true;
    propertyUniqueness[i]=singularAttributeBinding.isAlternateUniqueKey();
    i++;
  }
  hasFormulaProperties=foundFormula;
  lazyPropertyColumnAliases=ArrayHelper.to2DStringArray(lazyColAliases);
  lazyPropertyNames=ArrayHelper.toStringArray(lazyNames);
  lazyPropertyNumbers=ArrayHelper.toIntArray(lazyNumbers);
  lazyPropertyTypes=ArrayHelper.toTypeArray(lazyTypes);
  List<String> columns=new ArrayList<String>();
  List<Boolean> columnsLazy=new ArrayList<Boolean>();
  List<String> columnReaderTemplates=new ArrayList<String>();
  List<String> aliases=new ArrayList<String>();
  List<String> formulas=new ArrayList<String>();
  List<String> formulaAliases=new ArrayList<String>();
  List<String> formulaTemplates=new ArrayList<String>();
  List<Boolean> formulasLazy=new ArrayList<Boolean>();
  List<Type> types=new ArrayList<Type>();
  List<String> names=new ArrayList<String>();
  List<String> classes=new ArrayList<String>();
  List<String[]> templates=new ArrayList<String[]>();
  List<String[]> propColumns=new ArrayList<String[]>();
  List<String[]> propColumnReaders=new ArrayList<String[]>();
  List<String[]> propColumnReaderTemplates=new ArrayList<String[]>();
  List<FetchMode> joinedFetchesList=new ArrayList<FetchMode>();
  List<CascadeStyle> cascades=new ArrayList<CascadeStyle>();
  List<Boolean> definedBySubclass=new ArrayList<Boolean>();
  List<int[]> propColumnNumbers=new ArrayList<int[]>();
  List<int[]> propFormulaNumbers=new ArrayList<int[]>();
  List<Boolean> columnSelectables=new ArrayList<Boolean>();
  List<Boolean> propNullables=new ArrayList<Boolean>();
  for (  AttributeBinding attributeBinding : entityBinding.getSubEntityAttributeBindingClosure()) {
    if (attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding()) {
      continue;
    }
    if (!attributeBinding.getAttribute().isSingular()) {
      continue;
    }
    final SingularAttributeBinding singularAttributeBinding=(SingularAttributeBinding)attributeBinding;
    names.add(singularAttributeBinding.getAttribute().getName());
    classes.add(((EntityBinding)singularAttributeBinding.getContainer()).getEntity().getName());
    boolean isDefinedBySubclass=!thisClassProperties.contains(singularAttributeBinding);
    definedBySubclass.add(isDefinedBySubclass);
    propNullables.add(singularAttributeBinding.isNullable() || isDefinedBySubclass);
    types.add(singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping());
    final int span=singularAttributeBinding.getSimpleValueSpan();
    String[] cols=new String[span];
    String[] readers=new String[span];
    String[] readerTemplates=new String[span];
    String[] forms=new String[span];
    int[] colnos=new int[span];
    int[] formnos=new int[span];
    int l=0;
    Boolean lazy=singularAttributeBinding.isLazy() && lazyAvailable;
    for (    SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings()) {
      if (valueBinding.isDerived()) {
        DerivedValue derivedValue=DerivedValue.class.cast(valueBinding.getSimpleValue());
        String template=getTemplateFromString(derivedValue.getExpression(),factory);
        formnos[l]=formulaTemplates.size();
        colnos[l]=-1;
        formulaTemplates.add(template);
        forms[l]=template;
        formulas.add(derivedValue.getExpression());
        formulaAliases.add(derivedValue.getAlias(factory.getDialect()));
        formulasLazy.add(lazy);
      }
 else {
        org.hibernate.metamodel.relational.Column col=org.hibernate.metamodel.relational.Column.class.cast(valueBinding.getSimpleValue());
        String colName=col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect());
        colnos[l]=columns.size();
        formnos[l]=-1;
        columns.add(colName);
        cols[l]=colName;
        aliases.add(col.getAlias(factory.getDialect()));
        columnsLazy.add(lazy);
        columnSelectables.add(singularAttributeBinding.getAttribute().isSingular());
        readers[l]=col.getReadFragment() == null ? col.getColumnName().encloseInQuotesIfQuoted(factory.getDialect()) : col.getReadFragment();
        String readerTemplate=getTemplateFromColumn(col,factory);
        readerTemplates[l]=readerTemplate;
        columnReaderTemplates.add(readerTemplate);
      }
      l++;
    }
    propColumns.add(cols);
    propColumnReaders.add(readers);
    propColumnReaderTemplates.add(readerTemplates);
    templates.add(forms);
    propColumnNumbers.add(colnos);
    propFormulaNumbers.add(formnos);
    if (singularAttributeBinding.isAssociation()) {
      AssociationAttributeBinding associationAttributeBinding=(AssociationAttributeBinding)singularAttributeBinding;
      cascades.add(associationAttributeBinding.getCascadeStyle());
      joinedFetchesList.add(associationAttributeBinding.getFetchMode());
    }
 else {
      cascades.add(CascadeStyle.NONE);
      joinedFetchesList.add(FetchMode.SELECT);
    }
  }
  subclassColumnClosure=ArrayHelper.toStringArray(columns);
  subclassColumnAliasClosure=ArrayHelper.toStringArray(aliases);
  subclassColumnLazyClosure=ArrayHelper.toBooleanArray(columnsLazy);
  subclassColumnSelectableClosure=ArrayHelper.toBooleanArray(columnSelectables);
  subclassColumnReaderTemplateClosure=ArrayHelper.toStringArray(columnReaderTemplates);
  subclassFormulaClosure=ArrayHelper.toStringArray(formulas);
  subclassFormulaTemplateClosure=ArrayHelper.toStringArray(formulaTemplates);
  subclassFormulaAliasClosure=ArrayHelper.toStringArray(formulaAliases);
  subclassFormulaLazyClosure=ArrayHelper.toBooleanArray(formulasLazy);
  subclassPropertyNameClosure=ArrayHelper.toStringArray(names);
  subclassPropertySubclassNameClosure=ArrayHelper.toStringArray(classes);
  subclassPropertyTypeClosure=ArrayHelper.toTypeArray(types);
  subclassPropertyNullabilityClosure=ArrayHelper.toBooleanArray(propNullables);
  subclassPropertyFormulaTemplateClosure=ArrayHelper.to2DStringArray(templates);
  subclassPropertyColumnNameClosure=ArrayHelper.to2DStringArray(propColumns);
  subclassPropertyColumnReaderClosure=ArrayHelper.to2DStringArray(propColumnReaders);
  subclassPropertyColumnReaderTemplateClosure=ArrayHelper.to2DStringArray(propColumnReaderTemplates);
  subclassPropertyColumnNumberClosure=ArrayHelper.to2DIntArray(propColumnNumbers);
  subclassPropertyFormulaNumberClosure=ArrayHelper.to2DIntArray(propFormulaNumbers);
  subclassPropertyCascadeStyleClosure=cascades.toArray(new CascadeStyle[cascades.size()]);
  subclassPropertyFetchModeClosure=joinedFetchesList.toArray(new FetchMode[joinedFetchesList.size()]);
  propertyDefinedOnSubclass=ArrayHelper.toBooleanArray(definedBySubclass);
  Map<String,String> filterDefaultConditionsByName=new HashMap<String,String>();
  for (  FilterDefinition filterDefinition : entityBinding.getFilterDefinitions()) {
    filterDefaultConditionsByName.put(filterDefinition.getFilterName(),filterDefinition.getDefaultFilterCondition());
  }
  filterHelper=new FilterHelper(filterDefaultConditionsByName,factory.getDialect(),factory.getSqlFunctionRegistry());
  temporaryIdTableName=null;
  temporaryIdTableDDL=null;
}
