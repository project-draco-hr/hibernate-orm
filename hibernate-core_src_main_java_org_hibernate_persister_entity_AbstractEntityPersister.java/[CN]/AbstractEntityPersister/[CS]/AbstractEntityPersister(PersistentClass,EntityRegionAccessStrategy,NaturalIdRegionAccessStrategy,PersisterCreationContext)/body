{
  this.factory=creationContext.getSessionFactory();
  this.cacheAccessStrategy=cacheAccessStrategy;
  this.naturalIdRegionAccessStrategy=naturalIdRegionAccessStrategy;
  isLazyPropertiesCacheable=persistentClass.isLazyPropertiesCacheable();
  this.entityMetamodel=new EntityMetamodel(persistentClass,this,factory);
  this.entityTuplizer=this.entityMetamodel.getTuplizer();
  if (entityMetamodel.isMutable()) {
    this.entityEntryFactory=MutableEntityEntryFactory.INSTANCE;
  }
 else {
    this.entityEntryFactory=ImmutableEntityEntryFactory.INSTANCE;
  }
  int batch=persistentClass.getBatchSize();
  if (batch == -1) {
    batch=factory.getSessionFactoryOptions().getDefaultBatchFetchSize();
  }
  batchSize=batch;
  hasSubselectLoadableCollections=persistentClass.hasSubselectLoadableCollections();
  propertyMapping=new BasicEntityPropertyMapping(this);
  identifierColumnSpan=persistentClass.getIdentifier().getColumnSpan();
  rootTableKeyColumnNames=new String[identifierColumnSpan];
  rootTableKeyColumnReaders=new String[identifierColumnSpan];
  rootTableKeyColumnReaderTemplates=new String[identifierColumnSpan];
  identifierAliases=new String[identifierColumnSpan];
  rowIdName=persistentClass.getRootTable().getRowId();
  loaderName=persistentClass.getLoaderName();
  Iterator iter=persistentClass.getIdentifier().getColumnIterator();
  int i=0;
  while (iter.hasNext()) {
    Column col=(Column)iter.next();
    rootTableKeyColumnNames[i]=col.getQuotedName(factory.getDialect());
    rootTableKeyColumnReaders[i]=col.getReadExpr(factory.getDialect());
    rootTableKeyColumnReaderTemplates[i]=col.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
    identifierAliases[i]=col.getAlias(factory.getDialect(),persistentClass.getRootTable());
    i++;
  }
  if (persistentClass.isVersioned()) {
    versionColumnName=((Column)persistentClass.getVersion().getColumnIterator().next()).getQuotedName(factory.getDialect());
  }
 else {
    versionColumnName=null;
  }
  sqlWhereString=StringHelper.isNotEmpty(persistentClass.getWhere()) ? "( " + persistentClass.getWhere() + ") " : null;
  sqlWhereStringTemplate=sqlWhereString == null ? null : Template.renderWhereStringTemplate(sqlWhereString,factory.getDialect(),factory.getSqlFunctionRegistry());
  final boolean lazyAvailable=isInstrumented();
  int hydrateSpan=entityMetamodel.getPropertySpan();
  propertyColumnSpans=new int[hydrateSpan];
  propertySubclassNames=new String[hydrateSpan];
  propertyColumnAliases=new String[hydrateSpan][];
  propertyColumnNames=new String[hydrateSpan][];
  propertyColumnFormulaTemplates=new String[hydrateSpan][];
  propertyColumnReaderTemplates=new String[hydrateSpan][];
  propertyColumnWriters=new String[hydrateSpan][];
  propertyUniqueness=new boolean[hydrateSpan];
  propertySelectable=new boolean[hydrateSpan];
  propertyColumnUpdateable=new boolean[hydrateSpan][];
  propertyColumnInsertable=new boolean[hydrateSpan][];
  HashSet thisClassProperties=new HashSet();
  ArrayList lazyNames=new ArrayList();
  ArrayList lazyNumbers=new ArrayList();
  ArrayList lazyTypes=new ArrayList();
  ArrayList lazyColAliases=new ArrayList();
  iter=persistentClass.getPropertyClosureIterator();
  i=0;
  boolean foundFormula=false;
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    thisClassProperties.add(prop);
    int span=prop.getColumnSpan();
    propertyColumnSpans[i]=span;
    propertySubclassNames[i]=prop.getPersistentClass().getEntityName();
    String[] colNames=new String[span];
    String[] colAliases=new String[span];
    String[] colReaderTemplates=new String[span];
    String[] colWriters=new String[span];
    String[] formulaTemplates=new String[span];
    Iterator colIter=prop.getColumnIterator();
    int k=0;
    while (colIter.hasNext()) {
      Selectable thing=(Selectable)colIter.next();
      colAliases[k]=thing.getAlias(factory.getDialect(),prop.getValue().getTable());
      if (thing.isFormula()) {
        foundFormula=true;
        formulaTemplates[k]=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
      }
 else {
        Column col=(Column)thing;
        colNames[k]=col.getQuotedName(factory.getDialect());
        colReaderTemplates[k]=col.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
        colWriters[k]=col.getWriteExpr();
      }
      k++;
    }
    propertyColumnNames[i]=colNames;
    propertyColumnFormulaTemplates[i]=formulaTemplates;
    propertyColumnReaderTemplates[i]=colReaderTemplates;
    propertyColumnWriters[i]=colWriters;
    propertyColumnAliases[i]=colAliases;
    if (lazyAvailable && prop.isLazy()) {
      lazyNames.add(prop.getName());
      lazyNumbers.add(i);
      lazyTypes.add(prop.getValue().getType());
      lazyColAliases.add(colAliases);
    }
    propertyColumnUpdateable[i]=prop.getValue().getColumnUpdateability();
    propertyColumnInsertable[i]=prop.getValue().getColumnInsertability();
    propertySelectable[i]=prop.isSelectable();
    propertyUniqueness[i]=prop.getValue().isAlternateUniqueKey();
    if (prop.isLob() && getFactory().getDialect().forceLobAsLastValue()) {
      lobProperties.add(i);
    }
    i++;
  }
  hasFormulaProperties=foundFormula;
  lazyPropertyColumnAliases=ArrayHelper.to2DStringArray(lazyColAliases);
  lazyPropertyNames=ArrayHelper.toStringArray(lazyNames);
  lazyPropertyNumbers=ArrayHelper.toIntArray(lazyNumbers);
  lazyPropertyTypes=ArrayHelper.toTypeArray(lazyTypes);
  ArrayList columns=new ArrayList();
  ArrayList columnsLazy=new ArrayList();
  ArrayList columnReaderTemplates=new ArrayList();
  ArrayList aliases=new ArrayList();
  ArrayList formulas=new ArrayList();
  ArrayList formulaAliases=new ArrayList();
  ArrayList formulaTemplates=new ArrayList();
  ArrayList formulasLazy=new ArrayList();
  ArrayList types=new ArrayList();
  ArrayList names=new ArrayList();
  ArrayList classes=new ArrayList();
  ArrayList templates=new ArrayList();
  ArrayList propColumns=new ArrayList();
  ArrayList propColumnReaders=new ArrayList();
  ArrayList propColumnReaderTemplates=new ArrayList();
  ArrayList joinedFetchesList=new ArrayList();
  ArrayList cascades=new ArrayList();
  ArrayList definedBySubclass=new ArrayList();
  ArrayList propColumnNumbers=new ArrayList();
  ArrayList propFormulaNumbers=new ArrayList();
  ArrayList columnSelectables=new ArrayList();
  ArrayList propNullables=new ArrayList();
  iter=persistentClass.getSubclassPropertyClosureIterator();
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    names.add(prop.getName());
    classes.add(prop.getPersistentClass().getEntityName());
    boolean isDefinedBySubclass=!thisClassProperties.contains(prop);
    definedBySubclass.add(Boolean.valueOf(isDefinedBySubclass));
    propNullables.add(Boolean.valueOf(prop.isOptional() || isDefinedBySubclass));
    types.add(prop.getType());
    Iterator colIter=prop.getColumnIterator();
    String[] cols=new String[prop.getColumnSpan()];
    String[] readers=new String[prop.getColumnSpan()];
    String[] readerTemplates=new String[prop.getColumnSpan()];
    String[] forms=new String[prop.getColumnSpan()];
    int[] colnos=new int[prop.getColumnSpan()];
    int[] formnos=new int[prop.getColumnSpan()];
    int l=0;
    Boolean lazy=Boolean.valueOf(prop.isLazy() && lazyAvailable);
    while (colIter.hasNext()) {
      Selectable thing=(Selectable)colIter.next();
      if (thing.isFormula()) {
        String template=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
        formnos[l]=formulaTemplates.size();
        colnos[l]=-1;
        formulaTemplates.add(template);
        forms[l]=template;
        formulas.add(thing.getText(factory.getDialect()));
        formulaAliases.add(thing.getAlias(factory.getDialect()));
        formulasLazy.add(lazy);
      }
 else {
        Column col=(Column)thing;
        String colName=col.getQuotedName(factory.getDialect());
        colnos[l]=columns.size();
        formnos[l]=-1;
        columns.add(colName);
        cols[l]=colName;
        aliases.add(thing.getAlias(factory.getDialect(),prop.getValue().getTable()));
        columnsLazy.add(lazy);
        columnSelectables.add(Boolean.valueOf(prop.isSelectable()));
        readers[l]=col.getReadExpr(factory.getDialect());
        String readerTemplate=col.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
        readerTemplates[l]=readerTemplate;
        columnReaderTemplates.add(readerTemplate);
      }
      l++;
    }
    propColumns.add(cols);
    propColumnReaders.add(readers);
    propColumnReaderTemplates.add(readerTemplates);
    templates.add(forms);
    propColumnNumbers.add(colnos);
    propFormulaNumbers.add(formnos);
    joinedFetchesList.add(prop.getValue().getFetchMode());
    cascades.add(prop.getCascadeStyle());
  }
  subclassColumnClosure=ArrayHelper.toStringArray(columns);
  subclassColumnAliasClosure=ArrayHelper.toStringArray(aliases);
  subclassColumnLazyClosure=ArrayHelper.toBooleanArray(columnsLazy);
  subclassColumnSelectableClosure=ArrayHelper.toBooleanArray(columnSelectables);
  subclassColumnReaderTemplateClosure=ArrayHelper.toStringArray(columnReaderTemplates);
  subclassFormulaClosure=ArrayHelper.toStringArray(formulas);
  subclassFormulaTemplateClosure=ArrayHelper.toStringArray(formulaTemplates);
  subclassFormulaAliasClosure=ArrayHelper.toStringArray(formulaAliases);
  subclassFormulaLazyClosure=ArrayHelper.toBooleanArray(formulasLazy);
  subclassPropertyNameClosure=ArrayHelper.toStringArray(names);
  subclassPropertySubclassNameClosure=ArrayHelper.toStringArray(classes);
  subclassPropertyTypeClosure=ArrayHelper.toTypeArray(types);
  subclassPropertyNullabilityClosure=ArrayHelper.toBooleanArray(propNullables);
  subclassPropertyFormulaTemplateClosure=ArrayHelper.to2DStringArray(templates);
  subclassPropertyColumnNameClosure=ArrayHelper.to2DStringArray(propColumns);
  subclassPropertyColumnReaderClosure=ArrayHelper.to2DStringArray(propColumnReaders);
  subclassPropertyColumnReaderTemplateClosure=ArrayHelper.to2DStringArray(propColumnReaderTemplates);
  subclassPropertyColumnNumberClosure=ArrayHelper.to2DIntArray(propColumnNumbers);
  subclassPropertyFormulaNumberClosure=ArrayHelper.to2DIntArray(propFormulaNumbers);
  subclassPropertyCascadeStyleClosure=new CascadeStyle[cascades.size()];
  iter=cascades.iterator();
  int j=0;
  while (iter.hasNext()) {
    subclassPropertyCascadeStyleClosure[j++]=(CascadeStyle)iter.next();
  }
  subclassPropertyFetchModeClosure=new FetchMode[joinedFetchesList.size()];
  iter=joinedFetchesList.iterator();
  j=0;
  while (iter.hasNext()) {
    subclassPropertyFetchModeClosure[j++]=(FetchMode)iter.next();
  }
  propertyDefinedOnSubclass=new boolean[definedBySubclass.size()];
  iter=definedBySubclass.iterator();
  j=0;
  while (iter.hasNext()) {
    propertyDefinedOnSubclass[j++]=(Boolean)iter.next();
  }
  filterHelper=new FilterHelper(persistentClass.getFilters(),factory);
  boolean refCacheEntries=true;
  if (!factory.getSessionFactoryOptions().isDirectReferenceCacheEntriesEnabled()) {
    refCacheEntries=false;
  }
  if (entityMetamodel.isMutable()) {
    refCacheEntries=false;
  }
  for (  Type type : getSubclassPropertyTypeClosure()) {
    if (type.isAssociationType()) {
      refCacheEntries=false;
    }
  }
  useReferenceCacheEntries=refCacheEntries;
  this.cacheEntryHelper=buildCacheEntryHelper();
}
