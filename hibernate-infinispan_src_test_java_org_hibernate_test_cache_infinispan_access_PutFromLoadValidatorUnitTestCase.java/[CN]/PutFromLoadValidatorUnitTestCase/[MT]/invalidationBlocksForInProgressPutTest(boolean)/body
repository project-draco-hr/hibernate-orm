{
  final PutFromLoadValidator testee=new PutFromLoadValidator(new DefaultCacheManager(),null,PutFromLoadValidator.NAKED_PUT_INVALIDATION_PERIOD);
  final CountDownLatch removeLatch=new CountDownLatch(1);
  final CountDownLatch pferLatch=new CountDownLatch(1);
  final AtomicReference<Object> cache=new AtomicReference<Object>("INITIAL");
  Callable<Boolean> pferCallable=new Callable<Boolean>(){
    public Boolean call() throws Exception {
      testee.registerPendingPut(KEY1);
      if (testee.acquirePutFromLoadLock(KEY1)) {
        try {
          removeLatch.countDown();
          pferLatch.await();
          cache.set("PFER");
          return Boolean.TRUE;
        }
  finally {
          testee.releasePutFromLoadLock(KEY1);
        }
      }
      return Boolean.FALSE;
    }
  }
;
  Callable<Void> invalidateCallable=new Callable<Void>(){
    public Void call() throws Exception {
      removeLatch.await();
      if (keyOnly) {
        testee.invalidateKey(KEY1);
      }
 else {
        testee.invalidateRegion();
      }
      cache.set(null);
      return null;
    }
  }
;
  ExecutorService executorService=Executors.newCachedThreadPool();
  Future<Boolean> pferFuture=executorService.submit(pferCallable);
  Future<Void> invalidateFuture=executorService.submit(invalidateCallable);
  try {
    invalidateFuture.get(1,TimeUnit.SECONDS);
    fail("invalidateFuture did not block");
  }
 catch (  TimeoutException good) {
  }
  pferLatch.countDown();
  assertTrue(pferFuture.get(5,TimeUnit.SECONDS));
  invalidateFuture.get(5,TimeUnit.SECONDS);
  assertNull(cache.get());
}
