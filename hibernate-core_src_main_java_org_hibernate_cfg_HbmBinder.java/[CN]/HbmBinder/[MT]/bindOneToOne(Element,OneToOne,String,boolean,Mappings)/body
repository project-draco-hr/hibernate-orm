{
  bindColumns(node,oneToOne,isNullable,false,null,mappings);
  Attribute constrNode=node.attribute("constrained");
  boolean constrained=constrNode != null && constrNode.getValue().equals("true");
  oneToOne.setConstrained(constrained);
  oneToOne.setForeignKeyType(constrained ? ForeignKeyDirection.FOREIGN_KEY_FROM_PARENT : ForeignKeyDirection.FOREIGN_KEY_TO_PARENT);
  initOuterJoinFetchSetting(node,oneToOne);
  initLaziness(node,oneToOne,mappings,true);
  String embed=node.attributeValue("embed-xml");
  if (!StringHelper.isEmpty(embed) && !"true".equals(embed)) {
    LOG.embedXmlAttributesNoLongerSupported();
  }
  oneToOne.setEmbedded("true".equals(embed));
  Attribute fkNode=node.attribute("foreign-key");
  if (fkNode != null)   oneToOne.setForeignKeyName(fkNode.getValue());
  Attribute ukName=node.attribute("property-ref");
  if (ukName != null)   oneToOne.setReferencedPropertyName(ukName.getValue());
  oneToOne.setPropertyName(node.attributeValue("name"));
  oneToOne.setReferencedEntityName(getEntityName(node,mappings));
  String cascade=node.attributeValue("cascade");
  if (cascade != null && cascade.indexOf("delete-orphan") >= 0) {
    if (oneToOne.isConstrained()) {
      throw new MappingException("one-to-one attribute [" + path + "] does not support orphan delete as it is constrained");
    }
  }
}
