{
  bindColumnsOrFormula(node,manyToOne,path,isNullable,mappings);
  initOuterJoinFetchSetting(node,manyToOne);
  initLaziness(node,manyToOne,mappings,true);
  Attribute ukName=node.attribute("property-ref");
  if (ukName != null) {
    manyToOne.setReferencedPropertyName(ukName.getValue());
  }
  manyToOne.setReferencedEntityName(getEntityName(node,mappings));
  String embed=node.attributeValue("embed-xml");
  if (!StringHelper.isEmpty(embed) && !"true".equals(embed)) {
    LOG.embedXmlAttributesNoLongerSupported();
  }
  manyToOne.setEmbedded(embed == null || "true".equals(embed));
  String notFound=node.attributeValue("not-found");
  manyToOne.setIgnoreNotFound("ignore".equals(notFound));
  if (ukName != null && !manyToOne.isIgnoreNotFound()) {
    if (!node.getName().equals("many-to-many")) {
      mappings.addSecondPass(new ManyToOneSecondPass(manyToOne));
    }
  }
  Attribute fkNode=node.attribute("foreign-key");
  if (fkNode != null)   manyToOne.setForeignKeyName(fkNode.getValue());
  String cascade=node.attributeValue("cascade");
  if (cascade != null && cascade.indexOf("delete-orphan") >= 0) {
    if (!manyToOne.isLogicalOneToOne()) {
      throw new MappingException("many-to-one attribute [" + path + "] does not support orphan delete as it is not unique");
    }
  }
}
