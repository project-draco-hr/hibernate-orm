{
  LOG.debug("Building session factory");
  this.name=null;
  this.uuid=null;
  this.fetchProfiles=null;
  this.queryCache=null;
  this.updateTimestampsCache=null;
  this.queryCaches=null;
  this.currentSessionContext=null;
  this.sqlFunctionRegistry=null;
  this.transactionEnvironment=null;
  this.sessionFactoryOptions=sessionFactoryOptions;
  this.properties=createPropertiesFromMap(metadata.getServiceRegistry().getService(ConfigurationService.class).getSettings());
  this.settings=new SettingsFactory().buildSettings(properties,metadata.getServiceRegistry());
  this.serviceRegistry=metadata.getServiceRegistry().getService(SessionFactoryServiceRegistryFactory.class).buildServiceRegistry(this,metadata);
  this.jdbcServices=this.serviceRegistry.getService(JdbcServices.class);
  this.dialect=this.jdbcServices.getDialect();
  if (observer != null) {
    this.observer.addObserver(observer);
  }
  this.typeResolver=metadata.getTypeResolver().scope(this);
  this.typeHelper=new TypeLocatorImpl(typeResolver);
  this.filters=new HashMap<String,FilterDefinition>();
  for (  FilterDefinition filterDefinition : metadata.getFilterDefinitions()) {
    filters.put(filterDefinition.getFilterName(),filterDefinition);
  }
  LOG.debugf("Session factory constructed with filter configurations : %s",filters);
  LOG.debugf("Instantiating session factory with properties: %s",properties);
  settings.getRegionFactory().start(settings,properties);
  this.queryPlanCache=new QueryPlanCache(this);
class IntegratorObserver implements SessionFactoryObserver {
    private ArrayList<Integrator> integrators=new ArrayList<Integrator>();
    @Override public void sessionFactoryCreated(    SessionFactory factory){
    }
    @Override public void sessionFactoryClosed(    SessionFactory factory){
      for (      Integrator integrator : integrators) {
        integrator.disintegrate(SessionFactoryImpl.this,SessionFactoryImpl.this.serviceRegistry);
      }
    }
  }
  final IntegratorObserver integratorObserver=new IntegratorObserver();
  this.observer.addObserver(integratorObserver);
  for (  Integrator integrator : serviceRegistry.getService(IntegratorService.class).getIntegrators()) {
    integratorObserver.integrators.add(integrator);
  }
  identifierGenerators=new HashMap();
  for (  EntityBinding entityBinding : metadata.getEntityBindings()) {
    if (entityBinding.isRoot()) {
    }
  }
  StringBuilder stringBuilder=new StringBuilder();
  if (settings.getCacheRegionPrefix() != null) {
    stringBuilder.append(settings.getCacheRegionPrefix()).append('.');
  }
  final String cacheRegionPrefix=stringBuilder.toString();
  entityPersisters=new HashMap();
  Map<String,RegionAccessStrategy> entityAccessStrategies=new HashMap<String,RegionAccessStrategy>();
  Map<String,ClassMetadata> classMeta=new HashMap<String,ClassMetadata>();
  for (  EntityBinding model : metadata.getEntityBindings()) {
    EntityBinding rootEntityBinding=metadata.getRootEntityBinding(model.getEntity().getName());
    EntityRegionAccessStrategy accessStrategy=null;
    if (settings.isSecondLevelCacheEnabled() && rootEntityBinding.getCaching() != null && model.getCaching() != null && model.getCaching().getAccessType() != null) {
      final String cacheRegionName=cacheRegionPrefix + rootEntityBinding.getCaching().getRegion();
      accessStrategy=EntityRegionAccessStrategy.class.cast(entityAccessStrategies.get(cacheRegionName));
      if (accessStrategy == null) {
        final AccessType accessType=model.getCaching().getAccessType();
        LOG.trace("Building cache for entity data [" + model.getEntity().getName() + "]");
        EntityRegion entityRegion=settings.getRegionFactory().buildEntityRegion(cacheRegionName,properties,CacheDataDescriptionImpl.decode(model));
        accessStrategy=entityRegion.buildAccessStrategy(accessType);
        entityAccessStrategies.put(cacheRegionName,accessStrategy);
        allCacheRegions.put(cacheRegionName,entityRegion);
      }
    }
    EntityPersister cp=serviceRegistry.getService(PersisterFactory.class).createEntityPersister(model,accessStrategy,this,metadata);
    entityPersisters.put(model.getEntity().getName(),cp);
    classMeta.put(model.getEntity().getName(),cp.getClassMetadata());
  }
  this.classMetadata=Collections.unmodifiableMap(classMeta);
  Map<String,Set<String>> tmpEntityToCollectionRoleMap=new HashMap<String,Set<String>>();
  collectionPersisters=new HashMap();
  for (  PluralAttributeBinding model : metadata.getCollectionBindings()) {
    if (model.getAttribute() == null) {
      throw new IllegalStateException("No attribute defined for a PluralAttributeBinding: " + model);
    }
    if (model.getAttribute().isSingular()) {
      throw new IllegalStateException("PluralAttributeBinding has a Singular attribute defined: " + model.getAttribute().getName());
    }
    final String cacheRegionName=cacheRegionPrefix + model.getCacheRegionName();
    final AccessType accessType=AccessType.fromExternalName(model.getCacheConcurrencyStrategy());
    CollectionRegionAccessStrategy accessStrategy=null;
    if (accessType != null && settings.isSecondLevelCacheEnabled()) {
      LOG.trace("Building cache for collection data [" + model.getAttribute().getName() + "]");
      CollectionRegion collectionRegion=settings.getRegionFactory().buildCollectionRegion(cacheRegionName,properties,CacheDataDescriptionImpl.decode(model));
      accessStrategy=collectionRegion.buildAccessStrategy(accessType);
      entityAccessStrategies.put(cacheRegionName,accessStrategy);
      allCacheRegions.put(cacheRegionName,collectionRegion);
    }
    CollectionPersister persister=serviceRegistry.getService(PersisterFactory.class).createCollectionPersister(metadata,model,accessStrategy,this);
    collectionPersisters.put(model.getAttribute().getName(),persister.getCollectionMetadata());
    Type indexType=persister.getIndexType();
    if (indexType != null && indexType.isAssociationType() && !indexType.isAnyType()) {
      String entityName=((AssociationType)indexType).getAssociatedEntityName(this);
      Set roles=tmpEntityToCollectionRoleMap.get(entityName);
      if (roles == null) {
        roles=new HashSet();
        tmpEntityToCollectionRoleMap.put(entityName,roles);
      }
      roles.add(persister.getRole());
    }
    Type elementType=persister.getElementType();
    if (elementType.isAssociationType() && !elementType.isAnyType()) {
      String entityName=((AssociationType)elementType).getAssociatedEntityName(this);
      Set roles=tmpEntityToCollectionRoleMap.get(entityName);
      if (roles == null) {
        roles=new HashSet();
        tmpEntityToCollectionRoleMap.put(entityName,roles);
      }
      roles.add(persister.getRole());
    }
  }
  collectionMetadata=Collections.unmodifiableMap(collectionPersisters);
  Iterator itr=tmpEntityToCollectionRoleMap.entrySet().iterator();
  while (itr.hasNext()) {
    final Map.Entry entry=(Map.Entry)itr.next();
    entry.setValue(Collections.unmodifiableSet((Set)entry.getValue()));
  }
  collectionRolesByEntityParticipant=Collections.unmodifiableMap(tmpEntityToCollectionRoleMap);
  namedQueries=new HashMap<String,NamedQueryDefinition>();
  for (  NamedQueryDefinition namedQueryDefinition : metadata.getNamedQueryDefinitions()) {
    namedQueries.put(namedQueryDefinition.getName(),namedQueryDefinition);
  }
  namedSqlQueries=new HashMap<String,NamedSQLQueryDefinition>();
  for (  NamedSQLQueryDefinition namedNativeQueryDefinition : metadata.getNamedNativeQueryDefinitions()) {
    namedSqlQueries.put(namedNativeQueryDefinition.getName(),namedNativeQueryDefinition);
  }
  sqlResultSetMappings=new HashMap<String,ResultSetMappingDefinition>();
  for (  ResultSetMappingDefinition resultSetMappingDefinition : metadata.getResultSetMappingDefinitions()) {
    sqlResultSetMappings.put(resultSetMappingDefinition.getName(),resultSetMappingDefinition);
  }
  imports=new HashMap<String,String>();
  for (  Map.Entry<String,String> importEntry : metadata.getImports()) {
    imports.put(importEntry.getKey(),importEntry.getValue());
  }
  Iterator iter=entityPersisters.values().iterator();
  while (iter.hasNext()) {
    final EntityPersister persister=((EntityPersister)iter.next());
    persister.postInstantiate();
    registerEntityNameResolvers(persister);
  }
  iter=collectionPersisters.values().iterator();
  while (iter.hasNext()) {
    final CollectionPersister persister=((CollectionPersister)iter.next());
    persister.postInstantiate();
  }
}
