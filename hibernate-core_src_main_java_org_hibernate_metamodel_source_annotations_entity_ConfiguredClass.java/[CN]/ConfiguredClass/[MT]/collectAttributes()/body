{
  findTransientFieldAndMethodNames();
  ResolvedTypeWithMembers resolvedType=localBindingContext.resolveMemberTypes(localBindingContext.getResolvedType(clazz));
  for (  HierarchicType hierarchicType : resolvedType.allTypesAndOverrides()) {
    if (hierarchicType.getType().getErasedType().equals(clazz)) {
      resolvedType=localBindingContext.resolveMemberTypes(hierarchicType.getType());
      break;
    }
  }
  if (resolvedType == null) {
    throw new AssertionFailure("Unable to resolve types for " + clazz.getName());
  }
  Set<String> explicitlyConfiguredMemberNames=createExplicitlyConfiguredAccessProperties(resolvedType);
  if (AccessType.FIELD.equals(classAccessType)) {
    Field fields[]=clazz.getDeclaredFields();
    Field.setAccessible(fields,true);
    for (    Field field : fields) {
      if (isPersistentMember(transientFieldNames,explicitlyConfiguredMemberNames,field)) {
        createMappedAttribute(field,resolvedType,AccessType.FIELD);
      }
    }
  }
 else {
    Method[] methods=clazz.getDeclaredMethods();
    Method.setAccessible(methods,true);
    for (    Method method : methods) {
      if (isPersistentMember(transientMethodNames,explicitlyConfiguredMemberNames,method)) {
        createMappedAttribute(method,resolvedType,AccessType.PROPERTY);
      }
    }
  }
}
