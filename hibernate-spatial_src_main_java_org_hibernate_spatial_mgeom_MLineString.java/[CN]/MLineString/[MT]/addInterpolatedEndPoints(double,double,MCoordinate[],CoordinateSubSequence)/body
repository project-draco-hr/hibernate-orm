{
  boolean increasing=this.getMeasureDirection() == MGeometry.INCREASING;
  double fM, lM;
  if (increasing) {
    fM=fromM;
    lM=toM;
  }
 else {
    fM=toM;
    lM=fromM;
  }
  if (subsequence.firstIndex == -1) {
    MCoordinate fi=interpolate(mcoordinates[subsequence.lastIndex],mcoordinates[subsequence.lastIndex + 1],fM);
    subsequence.vertices.add(fi);
    MCoordinate li=interpolate(mcoordinates[subsequence.lastIndex],mcoordinates[subsequence.lastIndex + 1],lM);
    subsequence.vertices.add(li);
  }
 else {
    if (subsequence.firstIndex > 0 && (increasing && mcoordinates[subsequence.firstIndex].m > fromM || !increasing && mcoordinates[subsequence.firstIndex].m < toM)) {
      MCoordinate fi=interpolate(mcoordinates[subsequence.firstIndex - 1],mcoordinates[subsequence.firstIndex],fM);
      subsequence.vertices.add(0,fi);
    }
    if (subsequence.lastIndex < (mcoordinates.length - 1) && (increasing && mcoordinates[subsequence.lastIndex].m < toM || !increasing && mcoordinates[subsequence.lastIndex].m > fromM)) {
      MCoordinate li=interpolate(mcoordinates[subsequence.lastIndex],mcoordinates[subsequence.lastIndex + 1],lM);
      subsequence.vertices.add(li);
    }
  }
}
