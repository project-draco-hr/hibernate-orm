{
  if (!this.isMonotone(false)) {
    throw new MGeometryException(MGeometryException.OPERATION_REQUIRES_MONOTONE,"Operation requires geometry with monotonic measures");
  }
  if (fromM > toM) {
    return getCoordinatesBetween(toM,fromM);
  }
  MCoordinateSequence mc;
  if (!isOverlapping(fromM,toM)) {
    mc=new MCoordinateSequence(new MCoordinate[]{});
  }
 else {
    MCoordinate[] mcoordinates=(MCoordinate[])this.getCoordinates();
    CoordinateSubSequence subsequence=copyCoordinatesBetween(mcoordinates,fromM,toM,this.getMeasureDirection());
    addInterpolatedEndPoints(fromM,toM,mcoordinates,subsequence);
    MCoordinate[] ra=subsequence.vertices.toArray(new MCoordinate[subsequence.vertices.size()]);
    mc=new MCoordinateSequence(ra);
  }
  return new MCoordinateSequence[]{mc};
}
