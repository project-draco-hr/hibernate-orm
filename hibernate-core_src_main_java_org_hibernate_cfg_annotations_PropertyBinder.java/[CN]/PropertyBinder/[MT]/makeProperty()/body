{
  validateMake();
  LOG.debugf("Building property %s",name);
  Property prop=new Property();
  prop.setName(name);
  prop.setValue(value);
  prop.setLazy(lazy);
  prop.setLazyGroup(lazyGroup);
  prop.setCascade(cascade);
  prop.setPropertyAccessorName(accessType.getType());
  if (property != null) {
    prop.setValueGenerationStrategy(determineValueGenerationStrategy(property));
  }
  NaturalId naturalId=property != null ? property.getAnnotation(NaturalId.class) : null;
  if (naturalId != null) {
    if (!entityBinder.isRootEntity()) {
      throw new AnnotationException("@NaturalId only valid on root entity (or its @MappedSuperclasses)");
    }
    if (!naturalId.mutable()) {
      updatable=false;
    }
    prop.setNaturalIdentifier(true);
  }
  Lob lob=property != null ? property.getAnnotation(Lob.class) : null;
  prop.setLob(lob != null);
  prop.setInsertable(insertable);
  prop.setUpdateable(updatable);
  if (Collection.class.isInstance(value)) {
    prop.setOptimisticLocked(((Collection)value).isOptimisticLocked());
  }
 else {
    final OptimisticLock lockAnn=property != null ? property.getAnnotation(OptimisticLock.class) : null;
    if (lockAnn != null) {
      if (lockAnn.excluded() && (property.isAnnotationPresent(javax.persistence.Version.class) || property.isAnnotationPresent(Id.class) || property.isAnnotationPresent(EmbeddedId.class))) {
        throw new AnnotationException("@OptimisticLock.exclude=true incompatible with @Id, @EmbeddedId and @Version: " + StringHelper.qualify(holder.getPath(),name));
      }
    }
    final boolean isOwnedValue=!isToOneValue(value) || insertable;
    final boolean includeInOptimisticLockChecks=(lockAnn != null) ? !lockAnn.excluded() : isOwnedValue;
    prop.setOptimisticLocked(includeInOptimisticLockChecks);
  }
  LOG.tracev("Cascading {0} with {1}",name,cascade);
  this.mappingProperty=prop;
  return prop;
}
