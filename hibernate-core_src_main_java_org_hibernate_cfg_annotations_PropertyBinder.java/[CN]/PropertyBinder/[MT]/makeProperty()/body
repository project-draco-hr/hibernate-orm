{
  validateMake();
  LOG.debugf("Building property %s",name);
  Property prop=new Property();
  prop.setName(name);
  prop.setNodeName(name);
  prop.setValue(value);
  prop.setLazy(lazy);
  prop.setCascade(cascade);
  prop.setPropertyAccessorName(accessType.getType());
  Generated ann=property != null ? property.getAnnotation(Generated.class) : null;
  GenerationTime generated=ann != null ? ann.value() : null;
  if (generated != null) {
    if (!GenerationTime.NEVER.equals(generated)) {
      if (property.isAnnotationPresent(javax.persistence.Version.class) && GenerationTime.INSERT.equals(generated)) {
        throw new AnnotationException("@Generated(INSERT) on a @Version property not allowed, use ALWAYS: " + StringHelper.qualify(holder.getPath(),name));
      }
      insertable=false;
      if (GenerationTime.ALWAYS.equals(generated)) {
        updatable=false;
      }
      prop.setGeneration(PropertyGeneration.parse(generated.toString().toLowerCase()));
    }
  }
  NaturalId naturalId=property != null ? property.getAnnotation(NaturalId.class) : null;
  if (naturalId != null) {
    if (!naturalId.mutable()) {
      updatable=false;
    }
    prop.setNaturalIdentifier(true);
  }
  prop.setInsertable(insertable);
  prop.setUpdateable(updatable);
  OptimisticLock lockAnn=property != null ? property.getAnnotation(OptimisticLock.class) : null;
  if (lockAnn != null) {
    prop.setOptimisticLocked(!lockAnn.excluded());
    if (lockAnn.excluded() && (property.isAnnotationPresent(javax.persistence.Version.class) || property.isAnnotationPresent(Id.class) || property.isAnnotationPresent(EmbeddedId.class))) {
      throw new AnnotationException("@OptimisticLock.exclude=true incompatible with @Id, @EmbeddedId and @Version: " + StringHelper.qualify(holder.getPath(),name));
    }
  }
  LOG.trace("Cascading " + name + " with "+ cascade);
  this.mappingProperty=prop;
  return prop;
}
