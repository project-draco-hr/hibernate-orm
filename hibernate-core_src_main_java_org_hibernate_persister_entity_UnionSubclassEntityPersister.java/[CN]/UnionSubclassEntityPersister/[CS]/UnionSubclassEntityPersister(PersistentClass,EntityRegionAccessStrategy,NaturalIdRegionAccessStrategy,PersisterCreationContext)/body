{
  super(persistentClass,cacheAccessStrategy,naturalIdRegionAccessStrategy,creationContext);
  if (getIdentifierGenerator() instanceof IdentityGenerator) {
    throw new MappingException("Cannot use identity column key generation with <union-subclass> mapping for: " + getEntityName());
  }
  final SessionFactoryImplementor factory=creationContext.getSessionFactory();
  final Database database=creationContext.getMetadata().getDatabase();
  final JdbcEnvironment jdbcEnvironment=database.getJdbcEnvironment();
  tableName=determineTableName(persistentClass.getTable(),jdbcEnvironment);
  String sql;
  boolean callable=false;
  ExecuteUpdateResultCheckStyle checkStyle=null;
  sql=persistentClass.getCustomSQLInsert();
  callable=sql != null && persistentClass.isCustomInsertCallable();
  checkStyle=sql == null ? ExecuteUpdateResultCheckStyle.COUNT : persistentClass.getCustomSQLInsertCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(sql,callable) : persistentClass.getCustomSQLInsertCheckStyle();
  customSQLInsert=new String[]{sql};
  insertCallable=new boolean[]{callable};
  insertResultCheckStyles=new ExecuteUpdateResultCheckStyle[]{checkStyle};
  sql=persistentClass.getCustomSQLUpdate();
  callable=sql != null && persistentClass.isCustomUpdateCallable();
  checkStyle=sql == null ? ExecuteUpdateResultCheckStyle.COUNT : persistentClass.getCustomSQLUpdateCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(sql,callable) : persistentClass.getCustomSQLUpdateCheckStyle();
  customSQLUpdate=new String[]{sql};
  updateCallable=new boolean[]{callable};
  updateResultCheckStyles=new ExecuteUpdateResultCheckStyle[]{checkStyle};
  sql=persistentClass.getCustomSQLDelete();
  callable=sql != null && persistentClass.isCustomDeleteCallable();
  checkStyle=sql == null ? ExecuteUpdateResultCheckStyle.COUNT : persistentClass.getCustomSQLDeleteCheckStyle() == null ? ExecuteUpdateResultCheckStyle.determineDefault(sql,callable) : persistentClass.getCustomSQLDeleteCheckStyle();
  customSQLDelete=new String[]{sql};
  deleteCallable=new boolean[]{callable};
  deleteResultCheckStyles=new ExecuteUpdateResultCheckStyle[]{checkStyle};
  discriminatorValue=persistentClass.getSubclassId();
  discriminatorSQLValue=String.valueOf(persistentClass.getSubclassId());
  int subclassSpan=persistentClass.getSubclassSpan() + 1;
  subclassClosure=new String[subclassSpan];
  subclassClosure[0]=getEntityName();
  subclassByDiscriminatorValue.put(persistentClass.getSubclassId(),persistentClass.getEntityName());
  if (persistentClass.isPolymorphic()) {
    Iterator iter=persistentClass.getSubclassIterator();
    int k=1;
    while (iter.hasNext()) {
      Subclass sc=(Subclass)iter.next();
      subclassClosure[k++]=sc.getEntityName();
      subclassByDiscriminatorValue.put(sc.getSubclassId(),sc.getEntityName());
    }
  }
  int spacesSize=1 + persistentClass.getSynchronizedTables().size();
  spaces=new String[spacesSize];
  spaces[0]=tableName;
  Iterator iter=persistentClass.getSynchronizedTables().iterator();
  for (int i=1; i < spacesSize; i++) {
    spaces[i]=(String)iter.next();
  }
  HashSet subclassTables=new HashSet();
  iter=persistentClass.getSubclassTableClosureIterator();
  while (iter.hasNext()) {
    final Table table=(Table)iter.next();
    subclassTables.add(determineTableName(table,jdbcEnvironment));
  }
  subclassSpaces=ArrayHelper.toStringArray(subclassTables);
  subquery=generateSubquery(persistentClass,creationContext.getMetadata());
  if (isMultiTable()) {
    int idColumnSpan=getIdentifierColumnSpan();
    ArrayList tableNames=new ArrayList();
    ArrayList keyColumns=new ArrayList();
    if (!isAbstract()) {
      tableNames.add(tableName);
      keyColumns.add(getIdentifierColumnNames());
    }
    iter=persistentClass.getSubclassTableClosureIterator();
    while (iter.hasNext()) {
      Table tab=(Table)iter.next();
      if (!tab.isAbstractUnionTable()) {
        final String tableName=determineTableName(tab,jdbcEnvironment);
        tableNames.add(tableName);
        String[] key=new String[idColumnSpan];
        Iterator citer=tab.getPrimaryKey().getColumnIterator();
        for (int k=0; k < idColumnSpan; k++) {
          key[k]=((Column)citer.next()).getQuotedName(factory.getDialect());
        }
        keyColumns.add(key);
      }
    }
    constraintOrderedTableNames=ArrayHelper.toStringArray(tableNames);
    constraintOrderedKeyColumnNames=ArrayHelper.to2DStringArray(keyColumns);
  }
 else {
    constraintOrderedTableNames=new String[]{tableName};
    constraintOrderedKeyColumnNames=new String[][]{getIdentifierColumnNames()};
  }
  initLockers();
  initSubclassPropertyAliasesMap(persistentClass);
  postConstruct(creationContext.getMetadata());
}
