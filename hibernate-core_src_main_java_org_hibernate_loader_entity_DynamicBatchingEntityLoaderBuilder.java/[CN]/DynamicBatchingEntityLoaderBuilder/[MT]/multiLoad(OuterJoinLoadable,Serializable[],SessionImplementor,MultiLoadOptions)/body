{
  List result=CollectionHelper.arrayList(ids.length);
  if (loadOptions.isSessionCheckingEnabled()) {
    boolean foundAnyManagedEntities=false;
    final List<Serializable> nonManagedIds=new ArrayList<Serializable>();
    for (    Serializable id : ids) {
      final EntityKey entityKey=new EntityKey(id,persister);
      final Object managedEntity=session.getPersistenceContext().getEntity(entityKey);
      if (managedEntity != null) {
        foundAnyManagedEntities=true;
        result.add(managedEntity);
      }
 else {
        nonManagedIds.add(id);
      }
    }
    if (foundAnyManagedEntities) {
      if (nonManagedIds.isEmpty()) {
        return result;
      }
 else {
        ids=nonManagedIds.toArray((Serializable[])Array.newInstance(ids.getClass().getComponentType(),nonManagedIds.size()));
      }
    }
  }
  final LockOptions lockOptions=(loadOptions.getLockOptions() == null) ? new LockOptions(LockMode.NONE) : loadOptions.getLockOptions();
  int numberOfIdsLeft=ids.length;
  final int maxBatchSize;
  if (loadOptions.getBatchSize() != null && loadOptions.getBatchSize() > 0) {
    maxBatchSize=loadOptions.getBatchSize();
  }
 else {
    maxBatchSize=session.getFactory().getDialect().getDefaultBatchLoadSizingStrategy().determineOptimalBatchLoadSize(persister.getIdentifierType().getColumnSpan(session.getFactory()),numberOfIdsLeft);
  }
  int idPosition=0;
  while (numberOfIdsLeft > 0) {
    int batchSize=Math.min(numberOfIdsLeft,maxBatchSize);
    final DynamicEntityLoader batchingLoader=new DynamicEntityLoader(persister,batchSize,lockOptions,session.getFactory(),session.getLoadQueryInfluencers());
    Serializable[] idsInBatch=new Serializable[batchSize];
    System.arraycopy(ids,idPosition,idsInBatch,0,batchSize);
    QueryParameters qp=buildMultiLoadQueryParameters(persister,idsInBatch,lockOptions);
    result.addAll(batchingLoader.doEntityBatchFetch(session,qp,idsInBatch));
    numberOfIdsLeft=numberOfIdsLeft - batchSize;
    idPosition+=batchSize;
  }
  return result;
}
