{
  parse("select ord.id, sum(price.amount), count(item)\n" + "from Order as ord join ord.lineItems as item\n" + "join item.product as product, Catalog as catalog\n"+ "join catalog.prices as price\n"+ "where ord.paid = false\n"+ "and ord.customer = :customer\n"+ "and price.product = product\n"+ "and catalog.effectiveDate < sysdate\n"+ "and catalog.effectiveDate >= all (\n"+ "select cat.effectiveDate from Catalog as cat where cat.effectiveDate < sysdate)\n"+ "group by ord\n"+ "having sum(price.amount) > :minAmount\n"+ "order by sum(price.amount) desc");
  parse("select ord.id, sum(price.amount), count(item)\n" + "from Order as ord join ord.lineItems as item join item.product as product,\n" + "Catalog as catalog join catalog.prices as price\n"+ "where ord.paid = false and ord.customer = :customer\n"+ "and price.product = product and catalog = :currentCatalog\n"+ "group by ord having sum(price.amount) > :minAmount\n"+ "order by sum(price.amount) desc");
  parse("select count(payment), status.name \n" + "from Payment as payment \n" + "    join payment.currentStatus as status\n"+ "    join payment.statusChanges as statusChange\n"+ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"+ "    or (\n"+ "        statusChange.timeStamp = ( \n"+ "            select max(change.timeStamp) \n"+ "            from PaymentStatusChange change \n"+ "            where change.payment = payment\n"+ "        )\n"+ "        and statusChange.user <> :currentUser\n"+ "    )\n"+ "group by status.name, status.sortOrder\n"+ "order by status.sortOrder");
  parse("select count(payment), status.name \n" + "from Payment as payment\n" + "    join payment.currentStatus as status\n"+ "where payment.status.name <> PaymentStatus.AWAITING_APPROVAL\n"+ "    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user <> :currentUser\n"+ "group by status.name, status.sortOrder\n"+ "order by status.sortOrder");
  parse("select account, payment\n" + "from Account as account\n" + "    left outer join account.payments as payment\n"+ "where :currentUser in elements(account.holder.users)\n"+ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"+ "order by account.type.sortOrder, account.accountNumber, payment.dueDate");
  parse("select account, payment\n" + "from Account as account\n" + "    join account.holder.users as user\n"+ "    left outer join account.payments as payment\n"+ "where :currentUser = user\n"+ "    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)\n"+ "order by account.type.sortOrder, account.accountNumber, payment.dueDate");
}
