{
  Map<XClass,InheritanceState> inheritanceStatePerClass=new HashMap<XClass,InheritanceState>(orderedClasses.size());
  for (  XClass clazz : orderedClasses) {
    InheritanceState superclassState=InheritanceState.getSuperclassInheritanceState(clazz,inheritanceStatePerClass,reflectionManager);
    InheritanceState state=new InheritanceState(clazz);
    if (superclassState != null) {
      superclassState.setHasSiblings(true);
      InheritanceState superEntityState=InheritanceState.getInheritanceStateOfSuperEntity(clazz,inheritanceStatePerClass,reflectionManager);
      state.setHasParents(superEntityState != null);
      final boolean nonDefault=state.getType() != null && !InheritanceType.SINGLE_TABLE.equals(state.getType());
      if (superclassState.getType() != null) {
        final boolean mixingStrategy=state.getType() != null && !state.getType().equals(superclassState.getType());
        if (nonDefault && mixingStrategy) {
          log.warn("Mixing inheritance strategy in a entity hierarchy is not allowed, ignoring sub strategy in: {}",clazz.getName());
        }
        state.setType(superclassState.getType());
      }
    }
    inheritanceStatePerClass.put(clazz,state);
  }
  return inheritanceStatePerClass;
}
