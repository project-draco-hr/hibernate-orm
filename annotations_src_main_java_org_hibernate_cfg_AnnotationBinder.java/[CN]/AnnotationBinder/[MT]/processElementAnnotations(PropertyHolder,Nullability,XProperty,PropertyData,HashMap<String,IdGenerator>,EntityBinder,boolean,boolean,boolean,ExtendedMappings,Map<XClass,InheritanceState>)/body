{
  Ejb3Column[] columns=null;
  log.trace("Processing annotations of {}.{}",propertyHolder.getEntityName(),inferredData.getPropertyName());
  if (property.isAnnotationPresent(Parent.class)) {
    if (propertyHolder.isComponent()) {
      propertyHolder.setParentProperty(property.getName());
    }
 else {
      throw new AnnotationException("@Parent cannot be applied outside an embeddable object: " + BinderHelper.getPath(propertyHolder,inferredData));
    }
    return;
  }
  Ejb3JoinColumn[] joinColumns=buildExplicitJoinColumns(propertyHolder,property,inferredData,entityBinder,mappings);
  if (property.isAnnotationPresent(Column.class) || property.isAnnotationPresent(Formula.class)) {
    Column ann=property.getAnnotation(Column.class);
    Formula formulaAnn=property.getAnnotation(Formula.class);
    columns=Ejb3Column.buildColumnFromAnnotation(new Column[]{ann},formulaAnn,nullability,propertyHolder,inferredData,entityBinder.getSecondaryTables(),mappings);
  }
 else   if (property.isAnnotationPresent(Columns.class)) {
    Columns anns=property.getAnnotation(Columns.class);
    columns=Ejb3Column.buildColumnFromAnnotation(anns.columns(),null,nullability,propertyHolder,inferredData,entityBinder.getSecondaryTables(),mappings);
  }
  if (joinColumns == null && (property.isAnnotationPresent(ManyToOne.class) || property.isAnnotationPresent(OneToOne.class))) {
    joinColumns=buildDefaultJoinColumnsForXToOne(propertyHolder,property,inferredData,entityBinder,mappings);
  }
 else   if (joinColumns == null && (property.isAnnotationPresent(OneToMany.class) || property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(ElementCollection.class))) {
    OneToMany oneToMany=property.getAnnotation(OneToMany.class);
    String mappedBy=oneToMany != null ? oneToMany.mappedBy() : "";
    joinColumns=Ejb3JoinColumn.buildJoinColumns((JoinColumn[])null,mappedBy,entityBinder.getSecondaryTables(),propertyHolder,inferredData.getPropertyName(),mappings);
  }
 else   if (joinColumns == null && property.isAnnotationPresent(org.hibernate.annotations.Any.class)) {
    throw new AnnotationException("@Any requires an explicit @JoinColumn(s): " + BinderHelper.getPath(propertyHolder,inferredData));
  }
  if (columns == null && !property.isAnnotationPresent(ManyToMany.class)) {
    columns=Ejb3Column.buildColumnFromAnnotation(null,null,nullability,propertyHolder,inferredData,entityBinder.getSecondaryTables(),mappings);
  }
  if (nullability == Nullability.FORCED_NOT_NULL) {
    for (    Ejb3Column col : columns) {
      col.forceNotNull();
    }
  }
  final XClass returnedClass=inferredData.getClassOrElement();
  boolean isId;
  if (!entityBinder.isIgnoreIdAnnotations() && (property.isAnnotationPresent(Id.class) || property.isAnnotationPresent(EmbeddedId.class))) {
    isId=true;
    columns=overrideColumnFromMapsIdProperty("",columns,propertyHolder,entityBinder,mappings);
    processId(propertyHolder,property,inferredData,classGenerators,entityBinder,isIdentifierMapper,mappings,inheritanceStatePerClass,columns,returnedClass);
  }
 else   if (property.isAnnotationPresent(Version.class)) {
    if (isIdentifierMapper) {
      throw new AnnotationException("@IdClass class should not have @Version property");
    }
    if (!(propertyHolder.getPersistentClass() instanceof RootClass)) {
      throw new AnnotationException("Unable to define/override @Version on a subclass: " + propertyHolder.getEntityName());
    }
    if (!propertyHolder.isEntity()) {
      throw new AnnotationException("Unable to define @Version on an embedded class: " + propertyHolder.getEntityName());
    }
    log.trace("{} is a version property",inferredData.getPropertyName());
    RootClass rootClass=(RootClass)propertyHolder.getPersistentClass();
    PropertyBinder propBinder=new PropertyBinder();
    propBinder.setName(inferredData.getPropertyName());
    propBinder.setReturnedClassName(inferredData.getTypeName());
    propBinder.setLazy(false);
    propBinder.setAccessType(inferredData.getDefaultAccess());
    propBinder.setColumns(columns);
    propBinder.setHolder(propertyHolder);
    propBinder.setProperty(property);
    propBinder.setReturnedClass(inferredData.getPropertyClass());
    propBinder.setMappings(mappings);
    propBinder.setDeclaringClass(inferredData.getDeclaringClass());
    Property prop=propBinder.bind();
    propBinder.getSimpleValueBinder().setVersion(true);
    rootClass.setVersion(prop);
    final org.hibernate.mapping.MappedSuperclass superclass=BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(),inheritanceStatePerClass,mappings);
    if (superclass != null) {
      superclass.setDeclaredVersion(prop);
    }
 else {
      rootClass.setDeclaredVersion(prop);
    }
    SimpleValue simpleValue=(SimpleValue)prop.getValue();
    simpleValue.setNullValue("undefined");
    rootClass.setOptimisticLockMode(Versioning.OPTIMISTIC_LOCK_VERSION);
    log.trace("Version name: {}, unsavedValue: {}",rootClass.getVersion().getName(),((SimpleValue)rootClass.getVersion().getValue()).getNullValue());
  }
 else   if (property.isAnnotationPresent(ManyToOne.class)) {
    ManyToOne ann=property.getAnnotation(ManyToOne.class);
    if (property.isAnnotationPresent(Column.class) || property.isAnnotationPresent(Columns.class)) {
      throw new AnnotationException("@Column(s) not allowed on a @ManyToOne property: " + BinderHelper.getPath(propertyHolder,inferredData));
    }
    Cascade hibernateCascade=property.getAnnotation(Cascade.class);
    NotFound notFound=property.getAnnotation(NotFound.class);
    boolean ignoreNotFound=notFound != null && notFound.action().equals(NotFoundAction.IGNORE);
    OnDelete onDeleteAnn=property.getAnnotation(OnDelete.class);
    boolean onDeleteCascade=onDeleteAnn != null && OnDeleteAction.CASCADE.equals(onDeleteAnn.action());
    JoinTable assocTable=propertyHolder.getJoinTable(property);
    if (assocTable != null) {
      Join join=propertyHolder.addJoin(assocTable,false);
      for (      Ejb3JoinColumn joinColumn : joinColumns) {
        joinColumn.setSecondaryTableName(join.getTable().getName());
      }
    }
    final boolean mandatory=!ann.optional() || property.isAnnotationPresent(MapsId.class);
    bindManyToOne(getCascadeStrategy(ann.cascade(),hibernateCascade,false),joinColumns,!mandatory,ignoreNotFound,onDeleteCascade,ToOneBinder.getTargetEntity(inferredData,mappings),propertyHolder,inferredData,false,isIdentifierMapper,inSecondPass,mappings);
  }
 else   if (property.isAnnotationPresent(OneToOne.class)) {
    OneToOne ann=property.getAnnotation(OneToOne.class);
    if (property.isAnnotationPresent(Column.class) || property.isAnnotationPresent(Columns.class)) {
      throw new AnnotationException("@Column(s) not allowed on a @OneToOne property: " + BinderHelper.getPath(propertyHolder,inferredData));
    }
    boolean trueOneToOne=property.isAnnotationPresent(PrimaryKeyJoinColumn.class) || property.isAnnotationPresent(PrimaryKeyJoinColumns.class);
    Cascade hibernateCascade=property.getAnnotation(Cascade.class);
    NotFound notFound=property.getAnnotation(NotFound.class);
    boolean ignoreNotFound=notFound != null && notFound.action().equals(NotFoundAction.IGNORE);
    OnDelete onDeleteAnn=property.getAnnotation(OnDelete.class);
    boolean onDeleteCascade=onDeleteAnn != null && OnDeleteAction.CASCADE.equals(onDeleteAnn.action());
    JoinTable assocTable=propertyHolder.getJoinTable(property);
    if (assocTable != null) {
      Join join=propertyHolder.addJoin(assocTable,false);
      for (      Ejb3JoinColumn joinColumn : joinColumns) {
        joinColumn.setSecondaryTableName(join.getTable().getName());
      }
    }
    final boolean mandatory=!ann.optional() || property.isAnnotationPresent(MapsId.class);
    bindOneToOne(getCascadeStrategy(ann.cascade(),hibernateCascade,ann.orphanRemoval()),joinColumns,!mandatory,getFetchMode(ann.fetch()),ignoreNotFound,onDeleteCascade,ToOneBinder.getTargetEntity(inferredData,mappings),propertyHolder,inferredData,ann.mappedBy(),trueOneToOne,isIdentifierMapper,inSecondPass,mappings);
  }
 else   if (property.isAnnotationPresent(org.hibernate.annotations.Any.class)) {
    if (property.isAnnotationPresent(Column.class) || property.isAnnotationPresent(Columns.class)) {
      throw new AnnotationException("@Column(s) not allowed on a @Any property: " + BinderHelper.getPath(propertyHolder,inferredData));
    }
    Cascade hibernateCascade=property.getAnnotation(Cascade.class);
    OnDelete onDeleteAnn=property.getAnnotation(OnDelete.class);
    boolean onDeleteCascade=onDeleteAnn != null && OnDeleteAction.CASCADE.equals(onDeleteAnn.action());
    JoinTable assocTable=propertyHolder.getJoinTable(property);
    if (assocTable != null) {
      Join join=propertyHolder.addJoin(assocTable,false);
      for (      Ejb3JoinColumn joinColumn : joinColumns) {
        joinColumn.setSecondaryTableName(join.getTable().getName());
      }
    }
    bindAny(getCascadeStrategy(null,hibernateCascade,false),joinColumns,onDeleteCascade,nullability,propertyHolder,inferredData,entityBinder,isIdentifierMapper,mappings);
  }
 else   if (property.isAnnotationPresent(OneToMany.class) || property.isAnnotationPresent(ManyToMany.class) || property.isAnnotationPresent(CollectionOfElements.class)|| property.isAnnotationPresent(ElementCollection.class)|| property.isAnnotationPresent(ManyToAny.class)) {
    OneToMany oneToManyAnn=property.getAnnotation(OneToMany.class);
    ManyToMany manyToManyAnn=property.getAnnotation(ManyToMany.class);
    ElementCollection elementCollectionAnn=property.getAnnotation(ElementCollection.class);
    CollectionOfElements collectionOfElementsAnn=property.getAnnotation(CollectionOfElements.class);
    final IndexColumn indexColumn;
    if (property.isAnnotationPresent(OrderColumn.class)) {
      indexColumn=IndexColumn.buildColumnFromAnnotation(property.getAnnotation(OrderColumn.class),propertyHolder,inferredData,entityBinder.getSecondaryTables(),mappings);
    }
 else {
      indexColumn=IndexColumn.buildColumnFromAnnotation(property.getAnnotation(org.hibernate.annotations.IndexColumn.class),propertyHolder,inferredData,mappings);
    }
    CollectionBinder collectionBinder=CollectionBinder.getCollectionBinder(propertyHolder.getEntityName(),property,!indexColumn.isImplicit(),property.isAnnotationPresent(CollectionOfElements.class) || property.isAnnotationPresent(org.hibernate.annotations.MapKey.class));
    collectionBinder.setIndexColumn(indexColumn);
    MapKey mapKeyAnn=property.getAnnotation(MapKey.class);
    collectionBinder.setMapKey(mapKeyAnn);
    collectionBinder.setPropertyName(inferredData.getPropertyName());
    BatchSize batchAnn=property.getAnnotation(BatchSize.class);
    collectionBinder.setBatchSize(batchAnn);
    javax.persistence.OrderBy ejb3OrderByAnn=property.getAnnotation(javax.persistence.OrderBy.class);
    OrderBy orderByAnn=property.getAnnotation(OrderBy.class);
    collectionBinder.setEjb3OrderBy(ejb3OrderByAnn);
    collectionBinder.setSqlOrderBy(orderByAnn);
    Sort sortAnn=property.getAnnotation(Sort.class);
    collectionBinder.setSort(sortAnn);
    Cache cachAnn=property.getAnnotation(Cache.class);
    collectionBinder.setCache(cachAnn);
    collectionBinder.setPropertyHolder(propertyHolder);
    Cascade hibernateCascade=property.getAnnotation(Cascade.class);
    NotFound notFound=property.getAnnotation(NotFound.class);
    boolean ignoreNotFound=notFound != null && notFound.action().equals(NotFoundAction.IGNORE);
    collectionBinder.setIgnoreNotFound(ignoreNotFound);
    collectionBinder.setCollectionType(inferredData.getProperty().getElementClass());
    collectionBinder.setMappings(mappings);
    collectionBinder.setAccessType(inferredData.getDefaultAccess());
    Ejb3Column[] elementColumns;
    boolean isJPA2ForValueMapping=property.isAnnotationPresent(ElementCollection.class);
    PropertyData virtualProperty=isJPA2ForValueMapping ? inferredData : new WrappedInferredData(inferredData,"element");
    if (property.isAnnotationPresent(Column.class) || property.isAnnotationPresent(Formula.class)) {
      Column ann=property.getAnnotation(Column.class);
      Formula formulaAnn=property.getAnnotation(Formula.class);
      elementColumns=Ejb3Column.buildColumnFromAnnotation(new Column[]{ann},formulaAnn,nullability,propertyHolder,virtualProperty,entityBinder.getSecondaryTables(),mappings);
    }
 else     if (property.isAnnotationPresent(Columns.class)) {
      Columns anns=property.getAnnotation(Columns.class);
      elementColumns=Ejb3Column.buildColumnFromAnnotation(anns.columns(),null,nullability,propertyHolder,virtualProperty,entityBinder.getSecondaryTables(),mappings);
    }
 else {
      elementColumns=Ejb3Column.buildColumnFromAnnotation(null,null,nullability,propertyHolder,virtualProperty,entityBinder.getSecondaryTables(),mappings);
    }
{
      Column[] keyColumns=null;
      Boolean isJPA2=null;
      if (property.isAnnotationPresent(MapKeyColumn.class)) {
        isJPA2=Boolean.TRUE;
        keyColumns=new Column[]{new MapKeyColumnDelegator(property.getAnnotation(MapKeyColumn.class))};
      }
 else       if (property.isAnnotationPresent(org.hibernate.annotations.MapKey.class)) {
        if (isJPA2 == null) {
          isJPA2=Boolean.FALSE;
        }
        keyColumns=property.getAnnotation(org.hibernate.annotations.MapKey.class).columns();
      }
      if (isJPA2 == null) {
        isJPA2=Boolean.TRUE;
      }
      keyColumns=keyColumns != null && keyColumns.length > 0 ? keyColumns : null;
      PropertyData mapKeyVirtualProperty=new WrappedInferredData(inferredData,"mapkey");
      Ejb3Column[] mapColumns=Ejb3Column.buildColumnFromAnnotation(keyColumns,null,Nullability.FORCED_NOT_NULL,propertyHolder,isJPA2 ? inferredData : mapKeyVirtualProperty,isJPA2 ? "_KEY" : null,entityBinder.getSecondaryTables(),mappings);
      collectionBinder.setMapKeyColumns(mapColumns);
    }
{
      JoinColumn[] joinKeyColumns=null;
      Boolean isJPA2=null;
      if (property.isAnnotationPresent(MapKeyJoinColumns.class)) {
        isJPA2=Boolean.TRUE;
        final MapKeyJoinColumn[] mapKeyJoinColumns=property.getAnnotation(MapKeyJoinColumns.class).value();
        joinKeyColumns=new JoinColumn[mapKeyJoinColumns.length];
        int index=0;
        for (        MapKeyJoinColumn joinColumn : mapKeyJoinColumns) {
          joinKeyColumns[index]=new MapKeyJoinColumnDelegator(joinColumn);
          index++;
        }
        if (joinKeyColumns != null) {
          throw new AnnotationException("@MapKeyJoinColumn and @MapKeyJoinColumns used on the same property: " + BinderHelper.getPath(propertyHolder,inferredData));
        }
      }
 else       if (property.isAnnotationPresent(MapKeyJoinColumn.class)) {
        isJPA2=Boolean.TRUE;
        joinKeyColumns=new JoinColumn[]{new MapKeyJoinColumnDelegator(property.getAnnotation(MapKeyJoinColumn.class))};
      }
 else       if (property.isAnnotationPresent(org.hibernate.annotations.MapKeyManyToMany.class)) {
        if (isJPA2 == null) {
          isJPA2=Boolean.FALSE;
        }
        joinKeyColumns=property.getAnnotation(org.hibernate.annotations.MapKeyManyToMany.class).joinColumns();
      }
      if (isJPA2 == null) {
        isJPA2=Boolean.TRUE;
      }
      PropertyData mapKeyVirtualProperty=new WrappedInferredData(inferredData,"mapkey");
      Ejb3JoinColumn[] mapJoinColumns=Ejb3JoinColumn.buildJoinColumnsWithDefaultColumnSuffix(joinKeyColumns,null,entityBinder.getSecondaryTables(),propertyHolder,isJPA2 ? inferredData.getPropertyName() : mapKeyVirtualProperty.getPropertyName(),isJPA2 ? "_KEY" : null,mappings);
      collectionBinder.setMapKeyManyToManyColumns(mapJoinColumns);
    }
    collectionBinder.setEmbedded(property.isAnnotationPresent(Embedded.class));
    collectionBinder.setElementColumns(elementColumns);
    collectionBinder.setProperty(property);
    if (oneToManyAnn != null && manyToManyAnn != null) {
      throw new AnnotationException("@OneToMany and @ManyToMany on the same property is not allowed: " + propertyHolder.getEntityName() + "."+ inferredData.getPropertyName());
    }
    String mappedBy=null;
    if (oneToManyAnn != null) {
      for (      Ejb3JoinColumn column : joinColumns) {
        if (column.isSecondary()) {
          throw new NotYetImplementedException("Collections having FK in secondary table");
        }
      }
      collectionBinder.setFkJoinColumns(joinColumns);
      mappedBy=oneToManyAnn.mappedBy();
      collectionBinder.setTargetEntity(mappings.getReflectionManager().toXClass(oneToManyAnn.targetEntity()));
      collectionBinder.setCascadeStrategy(getCascadeStrategy(oneToManyAnn.cascade(),hibernateCascade,oneToManyAnn.orphanRemoval()));
      collectionBinder.setOneToMany(true);
    }
 else     if (elementCollectionAnn != null || collectionOfElementsAnn != null) {
      for (      Ejb3JoinColumn column : joinColumns) {
        if (column.isSecondary()) {
          throw new NotYetImplementedException("Collections having FK in secondary table");
        }
      }
      collectionBinder.setFkJoinColumns(joinColumns);
      mappedBy="";
      final Class<?> targetElement=elementCollectionAnn != null ? elementCollectionAnn.targetClass() : collectionOfElementsAnn.targetElement();
      collectionBinder.setTargetEntity(mappings.getReflectionManager().toXClass(targetElement));
      collectionBinder.setOneToMany(true);
    }
 else     if (manyToManyAnn != null) {
      mappedBy=manyToManyAnn.mappedBy();
      collectionBinder.setTargetEntity(mappings.getReflectionManager().toXClass(manyToManyAnn.targetEntity()));
      collectionBinder.setCascadeStrategy(getCascadeStrategy(manyToManyAnn.cascade(),hibernateCascade,false));
      collectionBinder.setOneToMany(false);
    }
 else     if (property.isAnnotationPresent(ManyToAny.class)) {
      mappedBy="";
      collectionBinder.setTargetEntity(mappings.getReflectionManager().toXClass(void.class));
      collectionBinder.setCascadeStrategy(getCascadeStrategy(null,hibernateCascade,false));
      collectionBinder.setOneToMany(false);
    }
    collectionBinder.setMappedBy(mappedBy);
    bindJoinedTableAssociation(property,mappings,entityBinder,collectionBinder,propertyHolder,inferredData,mappedBy);
    OnDelete onDeleteAnn=property.getAnnotation(OnDelete.class);
    boolean onDeleteCascade=onDeleteAnn != null && OnDeleteAction.CASCADE.equals(onDeleteAnn.action());
    collectionBinder.setCascadeDeleteEnabled(onDeleteCascade);
    if (isIdentifierMapper) {
      collectionBinder.setInsertable(false);
      collectionBinder.setUpdatable(false);
    }
    if (property.isAnnotationPresent(CollectionId.class)) {
      HashMap<String,IdGenerator> localGenerators=(HashMap<String,IdGenerator>)classGenerators.clone();
      localGenerators.putAll(buildLocalGenerators(property,mappings));
      collectionBinder.setLocalGenerators(localGenerators);
    }
    collectionBinder.setInheritanceStatePerClass(inheritanceStatePerClass);
    collectionBinder.setDeclaringClass(inferredData.getDeclaringClass());
    collectionBinder.bind();
  }
 else {
    boolean isComponent;
    Embeddable embeddableAnn=returnedClass.getAnnotation(Embeddable.class);
    Embedded embeddedAnn=property.getAnnotation(Embedded.class);
    isComponent=embeddedAnn != null || embeddableAnn != null;
    if (isComponent) {
      AccessType propertyAccessor=entityBinder.getPropertyAccessor(property);
      bindComponent(inferredData,propertyHolder,propertyAccessor,entityBinder,isIdentifierMapper,mappings,isComponentEmbedded,inheritanceStatePerClass);
    }
 else {
      boolean optional=true;
      boolean lazy=false;
      if (property.isAnnotationPresent(Basic.class)) {
        Basic ann=property.getAnnotation(Basic.class);
        optional=ann.optional();
        lazy=ann.fetch() == FetchType.LAZY;
      }
      if (!optional && nullability != Nullability.FORCED_NULL) {
        for (        Ejb3Column col : columns) {
          col.forceNotNull();
        }
      }
      if (propertyHolder.isOrWithinEmbeddedId()) {
        columns=overrideColumnFromMapsIdProperty(property.getName(),columns,propertyHolder,entityBinder,mappings);
      }
      PropertyBinder propBinder=new PropertyBinder();
      propBinder.setName(inferredData.getPropertyName());
      propBinder.setReturnedClassName(inferredData.getTypeName());
      propBinder.setLazy(lazy);
      propBinder.setAccessType(inferredData.getDefaultAccess());
      propBinder.setColumns(columns);
      propBinder.setHolder(propertyHolder);
      propBinder.setProperty(property);
      propBinder.setReturnedClass(inferredData.getPropertyClass());
      propBinder.setMappings(mappings);
      if (isIdentifierMapper) {
        propBinder.setInsertable(false);
        propBinder.setUpdatable(false);
      }
      propBinder.setDeclaringClass(inferredData.getDeclaringClass());
      propBinder.bind();
    }
  }
  Index index=property.getAnnotation(Index.class);
  if (index != null) {
    if (joinColumns != null) {
      for (      Ejb3Column column : joinColumns) {
        column.addIndex(index,inSecondPass);
      }
    }
 else {
      if (columns != null) {
        for (        Ejb3Column column : columns) {
          column.addIndex(index,inSecondPass);
        }
      }
    }
  }
  NaturalId naturalIdAnn=property.getAnnotation(NaturalId.class);
  if (naturalIdAnn != null) {
    if (joinColumns != null) {
      for (      Ejb3Column column : joinColumns) {
        column.addUniqueKey("_UniqueKey",inSecondPass);
      }
    }
 else {
      for (      Ejb3Column column : columns) {
        column.addUniqueKey("_UniqueKey",inSecondPass);
      }
    }
  }
}
