{
  int size=columnNames.length;
  Column[] columns=new Column[size];
  Set<Column> unbound=new HashSet<Column>();
  Set<Column> unboundNoLogical=new HashSet<Column>();
  for (int index=0; index < size; index++) {
    final String logicalColumnName=columnNames[index];
    try {
      final String physicalColumnName=getPhysicalColumnName(table,logicalColumnName);
      columns[index]=new Column(physicalColumnName);
      unbound.add(columns[index]);
    }
 catch (    MappingException e) {
      columns[index]=new Column(logicalColumnName);
      unboundNoLogical.add(columns[index]);
    }
  }
  if (unique) {
    if (StringHelper.isEmpty(keyName)) {
      final Identifier keyNameIdentifier=getMetadataBuildingOptions().getImplicitNamingStrategy().determineUniqueKeyName(new ImplicitUniqueKeyNameSource(){
        @Override public MetadataBuildingContext getBuildingContext(){
          return buildingContext;
        }
        @Override public Identifier getTableName(){
          return table.getNameIdentifier();
        }
        private List<Identifier> columnNameIdentifiers;
        @Override public List<Identifier> getColumnNames(){
          if (columnNameIdentifiers == null) {
            columnNameIdentifiers=toIdentifiers(columnNames);
          }
          return columnNameIdentifiers;
        }
      }
);
      keyName=keyNameIdentifier.render(getDatabase().getJdbcEnvironment().getDialect());
    }
    UniqueKey uk=table.getOrCreateUniqueKey(keyName);
    for (int i=0; i < columns.length; i++) {
      Column column=columns[i];
      String order=orderings != null ? orderings[i] : null;
      if (table.containsColumn(column)) {
        uk.addColumn(column,order);
        unbound.remove(column);
      }
    }
  }
 else {
    if (StringHelper.isEmpty(keyName)) {
      final Identifier keyNameIdentifier=getMetadataBuildingOptions().getImplicitNamingStrategy().determineIndexName(new ImplicitIndexNameSource(){
        @Override public MetadataBuildingContext getBuildingContext(){
          return buildingContext;
        }
        @Override public Identifier getTableName(){
          return table.getNameIdentifier();
        }
        private List<Identifier> columnNameIdentifiers;
        @Override public List<Identifier> getColumnNames(){
          if (columnNameIdentifiers == null) {
            columnNameIdentifiers=toIdentifiers(columnNames);
          }
          return columnNameIdentifiers;
        }
      }
);
      keyName=keyNameIdentifier.render(getDatabase().getJdbcEnvironment().getDialect());
    }
    Index index=table.getOrCreateIndex(keyName);
    for (int i=0; i < columns.length; i++) {
      Column column=columns[i];
      String order=orderings != null ? orderings[i] : null;
      if (table.containsColumn(column)) {
        index.addColumn(column,order);
        unbound.remove(column);
      }
    }
  }
  if (unbound.size() > 0 || unboundNoLogical.size() > 0) {
    StringBuilder sb=new StringBuilder("Unable to create ");
    if (unique) {
      sb.append("unique key constraint (");
    }
 else {
      sb.append("index (");
    }
    for (    String columnName : columnNames) {
      sb.append(columnName).append(", ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(") on table ").append(table.getName()).append(": database column ");
    for (    Column column : unbound) {
      sb.append("'").append(column.getName()).append("', ");
    }
    for (    Column column : unboundNoLogical) {
      sb.append("'").append(column.getName()).append("', ");
    }
    sb.setLength(sb.length() - 2);
    sb.append(" not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)");
    throw new AnnotationException(sb.toString());
  }
}
