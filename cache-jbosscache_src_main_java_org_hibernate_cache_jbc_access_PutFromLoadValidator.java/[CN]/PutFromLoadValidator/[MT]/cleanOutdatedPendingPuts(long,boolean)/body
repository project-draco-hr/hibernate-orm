{
  PendingPut toClean=null;
  if (lock) {
    pendingLock.lock();
  }
  try {
    long overaged=now - this.pendingPutOveragePeriod;
    long recent=now - this.pendingPutRecentPeriod;
    int pos=0;
    while (pendingQueue.size() > pos) {
      WeakReference<PendingPut> ref=pendingQueue.get(0);
      PendingPut item=ref.get();
      if (item == null || item.completed) {
        pendingQueue.remove(pos);
      }
 else       if (item.timestamp < overaged) {
        pendingQueue.remove(pos);
        overagePendingQueue.add(ref);
      }
 else       if (item.timestamp >= recent) {
        break;
      }
 else       if (pos > 2) {
        break;
      }
 else {
        pos++;
      }
    }
    long mustCleanTime=now - this.maxPendingPutDelay;
    while (overagePendingQueue.size() > 0) {
      WeakReference<PendingPut> ref=overagePendingQueue.get(0);
      PendingPut item=ref.get();
      if (item == null || item.completed) {
        overagePendingQueue.remove(0);
      }
 else {
        if (item.timestamp < mustCleanTime) {
          toClean=item;
        }
        break;
      }
    }
  }
  finally {
    if (lock) {
      pendingLock.unlock();
    }
  }
  if (toClean != null) {
    PendingPutMap map=pendingPuts.get(toClean.key);
    if (map != null) {
synchronized (map) {
        PendingPut cleaned=map.remove(toClean.owner);
        if (toClean.equals(cleaned) == false) {
          map.put(cleaned);
        }
 else         if (map.size() == 0) {
          pendingPuts.remove(toClean.key);
        }
      }
    }
  }
}
