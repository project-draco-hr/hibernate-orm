{
  if (ann == null)   return;
  ResultSetMappingDefinition definition=new ResultSetMappingDefinition(ann.name());
  log.info("Binding resultset mapping: {}",definition.getName());
  int entityAliasIndex=0;
  for (  EntityResult entity : ann.entities()) {
    List properties=new ArrayList();
    List propertyNames=new ArrayList();
    Map propertyresults=new HashMap();
    for (    FieldResult field : entity.fields()) {
      String name=field.name();
      if (name.indexOf('.') == -1) {
        properties.add(field);
        propertyNames.add(name);
      }
 else {
        PersistentClass pc=mappings.getClass(entity.entityClass().getName());
        if (pc == null) {
          throw new MappingException("Entity not found " + entity.entityClass().getName() + " in SqlResultsetMapping "+ ann.name());
        }
        int dotIndex=name.lastIndexOf('.');
        String reducedName=name.substring(0,dotIndex);
        Iterator parentPropIter=getSubPropertyIterator(pc,reducedName);
        List followers=getFollowers(parentPropIter,reducedName,name);
        int index=propertyNames.size();
        int followersSize=followers.size();
        for (int loop=0; loop < followersSize; loop++) {
          String follower=(String)followers.get(loop);
          int currentIndex=getIndexOfFirstMatchingProperty(propertyNames,follower);
          index=currentIndex != -1 && currentIndex < index ? currentIndex : index;
        }
        propertyNames.add(index,name);
        properties.add(index,field);
      }
    }
    Set uniqueReturnProperty=new HashSet();
    Iterator iterator=properties.iterator();
    while (iterator.hasNext()) {
      FieldResult propertyresult=(FieldResult)iterator.next();
      String name=propertyresult.name();
      if ("class".equals(name)) {
        throw new MappingException("class is not a valid property name to use in a @FieldResult, use @Entity(discriminatorColumn) instead");
      }
      ArrayList allResultColumns=new ArrayList();
      allResultColumns.add(propertyresult.column());
      if (uniqueReturnProperty.contains(name)) {
        throw new MappingException("duplicate @FieldResult for property " + name + " on @Entity "+ entity.entityClass().getName()+ " in "+ ann.name());
      }
      uniqueReturnProperty.add(name);
      String key=StringHelper.root(name);
      ArrayList intermediateResults=(ArrayList)propertyresults.get(key);
      if (intermediateResults == null) {
        propertyresults.put(key,allResultColumns);
      }
 else {
        intermediateResults.addAll(allResultColumns);
      }
    }
    Iterator entries=propertyresults.entrySet().iterator();
    while (entries.hasNext()) {
      Map.Entry entry=(Map.Entry)entries.next();
      if (entry.getValue() instanceof ArrayList) {
        ArrayList list=(ArrayList)entry.getValue();
        entry.setValue(list.toArray(new String[list.size()]));
      }
    }
    if (!BinderHelper.isDefault(entity.discriminatorColumn())) {
      propertyresults.put("class",new String[]{entity.discriminatorColumn()});
    }
    propertyresults=propertyresults.isEmpty() ? CollectionHelper.EMPTY_MAP : propertyresults;
    NativeSQLQueryRootReturn result=new NativeSQLQueryRootReturn("alias" + entityAliasIndex++,entity.entityClass().getName(),propertyresults,LockMode.READ);
    definition.addQueryReturn(result);
  }
  for (  ColumnResult column : ann.columns()) {
    definition.addQueryReturn(new NativeSQLQueryScalarReturn(column.name(),null));
  }
  if (isDefault) {
    mappings.addDefaultResultSetMapping(definition);
  }
 else {
    mappings.addResultSetMapping(definition);
  }
}
