{
  EntityManager em=getOrCreateEntityManager();
  final EntityManager em2=createIsolatedEntityManager();
  if (getDialect() instanceof HSQLDialect) {
    log.info("skipping testContendedPessimisticLock");
    return;
  }
  Lock lock=new Lock();
  Thread t=null;
  try {
    lock.setName("contendedLock");
    em.getTransaction().begin();
    em.persist(lock);
    em.getTransaction().commit();
    em.clear();
    em.getTransaction().begin();
    lock=em.getReference(Lock.class,lock.getId());
    em.lock(lock,LockModeType.PESSIMISTIC_WRITE);
    final Integer id=lock.getId();
    lock.getName();
    log.info("testContendedPessimisticLock: got write lock");
    final CountDownLatch latch=new CountDownLatch(1);
    t=new Thread(new Runnable(){
      public void run(){
        em2.getTransaction().begin();
        log.info("testContendedPessimisticLock: (BG) about to read write-locked entity");
        Lock lock2=em2.getReference(Lock.class,id);
        lock2.getName();
        log.info("testContendedPessimisticLock: (BG) read write-locked entity");
        em2.lock(lock2,LockModeType.PESSIMISTIC_READ);
        log.info("testContendedPessimisticLock: (BG) got read lock on entity");
        em2.getTransaction().commit();
        latch.countDown();
      }
    }
);
    t.setName("LockTest read lock");
    t.start();
    log.info("testContendedPessimisticLock:  wait on BG thread");
    boolean latchSet=latch.await(10,TimeUnit.SECONDS);
    log.info("testContendedPessimisticLock:  BG thread completed transaction");
    assertFalse("shouldn't be able to get read lock while another transaction has write lock",latchSet);
    em.getTransaction().commit();
  }
  finally {
    if (em.getTransaction().isActive()) {
      em.getTransaction().rollback();
    }
    if (t != null) {
      t.join();
    }
    em.getTransaction().begin();
    lock=em.getReference(Lock.class,lock.getId());
    em.remove(lock);
    em.getTransaction().commit();
    em.close();
    em2.close();
  }
}
