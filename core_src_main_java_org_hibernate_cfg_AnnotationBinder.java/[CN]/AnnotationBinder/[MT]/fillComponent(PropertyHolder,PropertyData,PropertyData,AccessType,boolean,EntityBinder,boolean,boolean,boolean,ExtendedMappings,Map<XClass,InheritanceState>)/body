{
  Component comp=createComponent(propertyHolder,inferredData,isComponentEmbedded,isIdentifierMapper,mappings);
  String subpath=BinderHelper.getPath(propertyHolder,inferredData);
  log.trace("Binding component with path: {}",subpath);
  PropertyHolder subHolder=PropertyHolderBuilder.buildPropertyHolder(comp,subpath,inferredData,propertyHolder,mappings);
  final XClass xClassProcessed=inferredData.getPropertyClass();
  List<PropertyData> classElements=new ArrayList<PropertyData>();
  XClass returnedClassOrElement=inferredData.getClassOrElement();
  List<PropertyData> baseClassElements=null;
  Map<String,PropertyData> orderedBaseClassElements=new HashMap<String,PropertyData>();
  XClass baseReturnedClassOrElement;
  if (baseInferredData != null) {
    baseClassElements=new ArrayList<PropertyData>();
    baseReturnedClassOrElement=baseInferredData.getClassOrElement();
    bindTypeDefs(baseReturnedClassOrElement,mappings);
    PropertyContainer propContainer=new PropertyContainer(baseReturnedClassOrElement,xClassProcessed);
    addElementsOfClass(baseClassElements,propertyAccessor,propContainer,mappings);
    for (    PropertyData element : baseClassElements) {
      orderedBaseClassElements.put(element.getPropertyName(),element);
    }
  }
  bindTypeDefs(returnedClassOrElement,mappings);
  PropertyContainer propContainer=new PropertyContainer(returnedClassOrElement,xClassProcessed);
  addElementsOfClass(classElements,propertyAccessor,propContainer,mappings);
  XClass superClass=xClassProcessed.getSuperclass();
  while (superClass != null && superClass.isAnnotationPresent(MappedSuperclass.class)) {
    propContainer=new PropertyContainer(superClass,xClassProcessed);
    addElementsOfClass(classElements,propertyAccessor,propContainer,mappings);
    superClass=superClass.getSuperclass();
  }
  if (baseClassElements != null) {
    if (!hasAnnotationsOnIdClass(xClassProcessed)) {
      for (int i=0; i < classElements.size(); i++) {
        final PropertyData idClassPropertyData=classElements.get(i);
        final PropertyData entityPropertyData=orderedBaseClassElements.get(idClassPropertyData.getPropertyName());
        if (propertyHolder.isInIdClass()) {
          if (entityPropertyData == null) {
            throw new AnnotationException("Property of @IdClass not found in entity " + baseInferredData.getPropertyClass().getName() + ": "+ idClassPropertyData.getPropertyName());
          }
          final boolean hasXToOneAnnotation=entityPropertyData.getProperty().isAnnotationPresent(ManyToOne.class) || entityPropertyData.getProperty().isAnnotationPresent(OneToOne.class);
          final boolean isOfDifferentType=!entityPropertyData.getClassOrElement().equals(idClassPropertyData.getClassOrElement());
          if (hasXToOneAnnotation && isOfDifferentType) {
          }
 else {
            classElements.set(i,entityPropertyData);
          }
        }
 else {
          classElements.set(i,entityPropertyData);
        }
      }
    }
  }
  for (  PropertyData propertyAnnotatedElement : classElements) {
    processElementAnnotations(subHolder,isNullable ? Nullability.NO_CONSTRAINT : Nullability.FORCED_NOT_NULL,propertyAnnotatedElement,new HashMap<String,IdGenerator>(),entityBinder,isIdentifierMapper,isComponentEmbedded,inSecondPass,mappings,inheritanceStatePerClass);
    XProperty property=propertyAnnotatedElement.getProperty();
    if (property.isAnnotationPresent(GeneratedValue.class) && property.isAnnotationPresent(Id.class)) {
      Map<String,IdGenerator> localGenerators=new HashMap<String,IdGenerator>();
      localGenerators.putAll(buildLocalGenerators(property,mappings));
      GeneratedValue generatedValue=property.getAnnotation(GeneratedValue.class);
      String generatorType=generatedValue != null ? generatorType(generatedValue.strategy(),mappings) : "assigned";
      String generator=generatedValue != null ? generatedValue.generator() : BinderHelper.ANNOTATION_STRING_DEFAULT;
      BinderHelper.makeIdGenerator((SimpleValue)comp.getProperty(property.getName()).getValue(),generatorType,generator,mappings,localGenerators);
    }
  }
  return comp;
}
