{
  final TransactionContext transactionContext=new TransactionContextImpl(new TransactionEnvironmentImpl(serviceRegistry)){
    @Override public ConnectionReleaseMode getConnectionReleaseMode(){
      return ConnectionReleaseMode.AFTER_STATEMENT;
    }
  }
;
  final TransactionCoordinatorImpl transactionCoordinator=new TransactionCoordinatorImpl(null,transactionContext);
  final JournalingTransactionObserver transactionObserver=new JournalingTransactionObserver();
  transactionCoordinator.addObserver(transactionObserver);
  JdbcCoordinator jdbcCoordinator=transactionCoordinator.getJdbcCoordinator();
  LogicalConnectionImplementor logicalConnection=jdbcCoordinator.getLogicalConnection();
  Statement statement=jdbcCoordinator.getStatementPreparer().createStatement();
  jdbcCoordinator.getResultSetReturn().execute(statement,"drop table SANDBOX_JDBC_TST if exists");
  jdbcCoordinator.getResultSetReturn().execute(statement,"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )");
  assertTrue(jdbcCoordinator.hasRegisteredResources());
  assertTrue(logicalConnection.isPhysicallyConnected());
  jdbcCoordinator.release(statement);
  assertFalse(jdbcCoordinator.hasRegisteredResources());
  assertFalse(logicalConnection.isPhysicallyConnected());
  JtaPlatform instance=serviceRegistry.getService(JtaPlatform.class);
  TransactionManager transactionManager=instance.retrieveTransactionManager();
  transactionManager.begin();
  TransactionImplementor txn=transactionCoordinator.getTransaction();
  txn.begin();
  assertEquals(1,transactionObserver.getBegins());
  assertFalse(txn.isInitiator());
  try {
    PreparedStatement ps=jdbcCoordinator.getStatementPreparer().prepareStatement("insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )");
    ps.setLong(1,1);
    ps.setString(2,"name");
    jdbcCoordinator.getResultSetReturn().execute(ps);
    assertTrue(jdbcCoordinator.hasRegisteredResources());
    jdbcCoordinator.release(ps);
    assertFalse(jdbcCoordinator.hasRegisteredResources());
    ps=jdbcCoordinator.getStatementPreparer().prepareStatement("select * from SANDBOX_JDBC_TST");
    jdbcCoordinator.getResultSetReturn().extract(ps);
    ps=jdbcCoordinator.getStatementPreparer().prepareStatement("delete from SANDBOX_JDBC_TST");
    jdbcCoordinator.getResultSetReturn().execute(ps);
    assertTrue(jdbcCoordinator.hasRegisteredResources());
    assertTrue(logicalConnection.isPhysicallyConnected());
    txn.commit();
    assertTrue(jdbcCoordinator.hasRegisteredResources());
    assertTrue(logicalConnection.isPhysicallyConnected());
    assertEquals(0,transactionObserver.getBeforeCompletions());
    assertEquals(0,transactionObserver.getAfterCompletions());
    transactionManager.commit();
    assertFalse(jdbcCoordinator.hasRegisteredResources());
    assertFalse(logicalConnection.isPhysicallyConnected());
    assertEquals(1,transactionObserver.getBeforeCompletions());
    assertEquals(1,transactionObserver.getAfterCompletions());
  }
 catch (  SQLException sqle) {
    try {
      transactionManager.rollback();
    }
 catch (    Exception ignore) {
    }
    fail("incorrect exception type : SQLException");
  }
catch (  Throwable reThrowable) {
    try {
      transactionManager.rollback();
    }
 catch (    Exception ignore) {
    }
    throw reThrowable;
  }
 finally {
    logicalConnection.close();
    transactionContext.getTransactionEnvironment().getSessionFactory().close();
  }
}
