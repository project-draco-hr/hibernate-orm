{
  ConstPool cp=classfile.getConstPool();
  int target_type_index=cp.addClassInfo(this.targetBean.getName());
  String desc=GET_SETTER_DESC;
  MethodInfo mi=new MethodInfo(cp,GENERATED_SETTER_NAME,desc);
  Bytecode code=new Bytecode(cp,4,6);
  StackMapTable stackmap=null;
  if (setters.length > 0) {
    int start, end;
    code.addIconst(0);
    code.addIstore(3);
    code.addAload(1);
    code.addCheckcast(this.targetBean.getName());
    code.addAstore(4);
    start=code.currentPc();
    int lastIndex=0;
    for (int i=0; i < setters.length; ++i) {
      if (setters[i] != null) {
        int diff=i - lastIndex;
        if (diff > 0) {
          code.addOpcode(Opcode.IINC);
          code.add(3);
          code.add(diff);
          lastIndex=i;
        }
      }
      code.addAload(4);
      code.addAload(2);
      code.addIconst(i);
      code.addOpcode(Opcode.AALOAD);
      Class[] setterParamTypes=setters[i].getParameterTypes();
      Class setterParamType=setterParamTypes[0];
      if (setterParamType.isPrimitive()) {
        this.addUnwrapper(classfile,code,setterParamType);
      }
 else {
        code.addCheckcast(setterParamType.getName());
      }
      String rawSetterMethod_desc=RuntimeSupport.makeDescriptor(setters[i]);
      if (!this.targetBean.isInterface()) {
        code.addInvokevirtual(target_type_index,setters[i].getName(),rawSetterMethod_desc);
      }
 else {
        Class[] params=setters[i].getParameterTypes();
        int size;
        if (params[0].equals(Double.TYPE) || params[0].equals(Long.TYPE)) {
          size=3;
        }
 else {
          size=2;
        }
        code.addInvokeinterface(target_type_index,setters[i].getName(),rawSetterMethod_desc,size);
      }
    }
    end=code.currentPc();
    code.addOpcode(Opcode.RETURN);
    int throwableType_index=cp.addClassInfo(THROWABLE_CLASS_NAME);
    int handler_pc=code.currentPc();
    code.addExceptionHandler(start,end,handler_pc,throwableType_index);
    code.addAstore(5);
    code.addNew(BULKEXCEPTION_CLASS_NAME);
    code.addOpcode(Opcode.DUP);
    code.addAload(5);
    code.addIload(3);
    String cons_desc="(Ljava/lang/Throwable;I)V";
    code.addInvokespecial(BULKEXCEPTION_CLASS_NAME,MethodInfo.nameInit,cons_desc);
    code.addOpcode(Opcode.ATHROW);
    StackMapTable.Writer writer=new StackMapTable.Writer(32);
    int[] localTags={StackMapTable.OBJECT,StackMapTable.OBJECT,StackMapTable.OBJECT,StackMapTable.INTEGER};
    int[] localData={cp.getThisClassInfo(),cp.addClassInfo("java/lang/Object"),cp.addClassInfo("[Ljava/lang/Object;"),0};
    int[] stackTags={StackMapTable.OBJECT};
    int[] stackData={throwableType_index};
    writer.fullFrame(handler_pc,localTags,localData,stackTags,stackData);
    stackmap=writer.toStackMapTable(cp);
  }
 else {
    code.addOpcode(Opcode.RETURN);
  }
  CodeAttribute ca=code.toCodeAttribute();
  if (stackmap != null) {
    ca.setAttribute(stackmap);
  }
  mi.setCodeAttribute(ca);
  mi.setAccessFlags(AccessFlag.PUBLIC);
  classfile.addMethod(mi);
}
