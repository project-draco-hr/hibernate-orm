{
switch (x.getType()) {
case OR:
    x.setType(AND);
  x.setText("{and}");
negateNode(x.getFirstChild());
negateNode(x.getFirstChild().getNextSibling());
return x;
case AND:
x.setType(OR);
x.setText("{or}");
negateNode(x.getFirstChild());
negateNode(x.getFirstChild().getNextSibling());
return x;
case EQ:
x.setType(NE);
x.setText("{not}" + x.getText());
return x;
case NE:
x.setType(EQ);
x.setText("{not}" + x.getText());
return x;
case GT:
x.setType(LE);
x.setText("{not}" + x.getText());
return x;
case LT:
x.setType(GE);
x.setText("{not}" + x.getText());
return x;
case GE:
x.setType(LT);
x.setText("{not}" + x.getText());
return x;
case LE:
x.setType(GT);
x.setText("{not}" + x.getText());
return x;
case LIKE:
x.setType(NOT_LIKE);
x.setText("{not}" + x.getText());
return x;
case NOT_LIKE:
x.setType(LIKE);
x.setText("{not}" + x.getText());
return x;
case IN:
x.setType(NOT_IN);
x.setText("{not}" + x.getText());
return x;
case NOT_IN:
x.setType(IN);
x.setText("{not}" + x.getText());
return x;
case IS_NULL:
x.setType(IS_NOT_NULL);
x.setText("{not}" + x.getText());
return x;
case IS_NOT_NULL:
x.setType(IS_NULL);
x.setText("{not}" + x.getText());
return x;
case BETWEEN:
x.setType(NOT_BETWEEN);
x.setText("{not}" + x.getText());
return x;
case NOT_BETWEEN:
x.setType(BETWEEN);
x.setText("{not}" + x.getText());
return x;
default :
return super.negateNode(x);
}
}
