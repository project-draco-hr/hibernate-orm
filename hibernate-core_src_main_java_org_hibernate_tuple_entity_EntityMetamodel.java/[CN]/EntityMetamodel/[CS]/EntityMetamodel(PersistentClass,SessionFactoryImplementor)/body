{
  this.sessionFactory=sessionFactory;
  name=persistentClass.getEntityName();
  rootName=persistentClass.getRootClass().getEntityName();
  entityType=sessionFactory.getTypeResolver().getTypeFactory().manyToOne(name);
  identifierProperty=PropertyFactory.buildIdentifierProperty(persistentClass,sessionFactory.getIdentifierGenerator(rootName));
  versioned=persistentClass.isVersioned();
  boolean lazyAvailable=persistentClass.hasPojoRepresentation() && FieldInterceptionHelper.isInstrumented(persistentClass.getMappedClass());
  boolean hasLazy=false;
  propertySpan=persistentClass.getPropertyClosureSpan();
  properties=new StandardProperty[propertySpan];
  List naturalIdNumbers=new ArrayList();
  propertyNames=new String[propertySpan];
  propertyTypes=new Type[propertySpan];
  propertyUpdateability=new boolean[propertySpan];
  propertyInsertability=new boolean[propertySpan];
  insertInclusions=new ValueInclusion[propertySpan];
  updateInclusions=new ValueInclusion[propertySpan];
  nonlazyPropertyUpdateability=new boolean[propertySpan];
  propertyCheckability=new boolean[propertySpan];
  propertyNullability=new boolean[propertySpan];
  propertyVersionability=new boolean[propertySpan];
  propertyLaziness=new boolean[propertySpan];
  cascadeStyles=new CascadeStyle[propertySpan];
  Iterator iter=persistentClass.getPropertyClosureIterator();
  int i=0;
  int tempVersionProperty=NO_VERSION_INDX;
  boolean foundCascade=false;
  boolean foundCollection=false;
  boolean foundMutable=false;
  boolean foundNonIdentifierPropertyNamedId=false;
  boolean foundInsertGeneratedValue=false;
  boolean foundUpdateGeneratedValue=false;
  boolean foundUpdateableNaturalIdProperty=false;
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    if (prop == persistentClass.getVersion()) {
      tempVersionProperty=i;
      properties[i]=PropertyFactory.buildVersionProperty(prop,lazyAvailable);
    }
 else {
      properties[i]=PropertyFactory.buildStandardProperty(prop,lazyAvailable);
    }
    if (prop.isNaturalIdentifier()) {
      naturalIdNumbers.add(new Integer(i));
      if (prop.isUpdateable()) {
        foundUpdateableNaturalIdProperty=true;
      }
    }
    if ("id".equals(prop.getName())) {
      foundNonIdentifierPropertyNamedId=true;
    }
    boolean lazy=prop.isLazy() && lazyAvailable;
    if (lazy)     hasLazy=true;
    propertyLaziness[i]=lazy;
    propertyNames[i]=properties[i].getName();
    propertyTypes[i]=properties[i].getType();
    propertyNullability[i]=properties[i].isNullable();
    propertyUpdateability[i]=properties[i].isUpdateable();
    propertyInsertability[i]=properties[i].isInsertable();
    insertInclusions[i]=determineInsertValueGenerationType(prop,properties[i]);
    updateInclusions[i]=determineUpdateValueGenerationType(prop,properties[i]);
    propertyVersionability[i]=properties[i].isVersionable();
    nonlazyPropertyUpdateability[i]=properties[i].isUpdateable() && !lazy;
    propertyCheckability[i]=propertyUpdateability[i] || (propertyTypes[i].isAssociationType() && ((AssociationType)propertyTypes[i]).isAlwaysDirtyChecked());
    cascadeStyles[i]=properties[i].getCascadeStyle();
    if (properties[i].isLazy()) {
      hasLazy=true;
    }
    if (properties[i].getCascadeStyle() != CascadeStyle.NONE) {
      foundCascade=true;
    }
    if (indicatesCollection(properties[i].getType())) {
      foundCollection=true;
    }
    if (propertyTypes[i].isMutable() && propertyCheckability[i]) {
      foundMutable=true;
    }
    if (insertInclusions[i] != ValueInclusion.NONE) {
      foundInsertGeneratedValue=true;
    }
    if (updateInclusions[i] != ValueInclusion.NONE) {
      foundUpdateGeneratedValue=true;
    }
    mapPropertyToIndex(prop,i);
    i++;
  }
  if (naturalIdNumbers.size() == 0) {
    naturalIdPropertyNumbers=null;
    hasImmutableNaturalId=false;
  }
 else {
    naturalIdPropertyNumbers=ArrayHelper.toIntArray(naturalIdNumbers);
    hasImmutableNaturalId=!foundUpdateableNaturalIdProperty;
  }
  hasInsertGeneratedValues=foundInsertGeneratedValue;
  hasUpdateGeneratedValues=foundUpdateGeneratedValue;
  hasCascades=foundCascade;
  hasNonIdentifierPropertyNamedId=foundNonIdentifierPropertyNamedId;
  versionPropertyIndex=tempVersionProperty;
  hasLazyProperties=hasLazy;
  if (hasLazyProperties) {
    log.info("lazy property fetching available for: " + name);
  }
  lazy=persistentClass.isLazy() && (!persistentClass.hasPojoRepresentation() || !ReflectHelper.isFinalClass(persistentClass.getProxyInterface()));
  mutable=persistentClass.isMutable();
  if (persistentClass.isAbstract() == null) {
    isAbstract=persistentClass.hasPojoRepresentation() && ReflectHelper.isAbstractClass(persistentClass.getMappedClass());
  }
 else {
    isAbstract=persistentClass.isAbstract().booleanValue();
    if (!isAbstract && persistentClass.hasPojoRepresentation() && ReflectHelper.isAbstractClass(persistentClass.getMappedClass())) {
      log.warn("entity [" + name + "] is abstract-class/interface explicitly mapped as non-abstract; be sure to supply entity-names");
    }
  }
  selectBeforeUpdate=persistentClass.hasSelectBeforeUpdate();
  dynamicUpdate=persistentClass.useDynamicUpdate();
  dynamicInsert=persistentClass.useDynamicInsert();
  polymorphic=persistentClass.isPolymorphic();
  explicitPolymorphism=persistentClass.isExplicitPolymorphism();
  inherited=persistentClass.isInherited();
  superclass=inherited ? persistentClass.getSuperclass().getEntityName() : null;
  hasSubclasses=persistentClass.hasSubclasses();
  optimisticLockMode=persistentClass.getOptimisticLockMode();
  if (optimisticLockMode > Versioning.OPTIMISTIC_LOCK_VERSION && !dynamicUpdate) {
    throw new MappingException("optimistic-lock=all|dirty requires dynamic-update=\"true\": " + name);
  }
  if (versionPropertyIndex != NO_VERSION_INDX && optimisticLockMode > Versioning.OPTIMISTIC_LOCK_VERSION) {
    throw new MappingException("version and optimistic-lock=all|dirty are not a valid combination : " + name);
  }
  hasCollections=foundCollection;
  hasMutableProperties=foundMutable;
  iter=persistentClass.getSubclassIterator();
  while (iter.hasNext()) {
    subclassEntityNames.add(((PersistentClass)iter.next()).getEntityName());
  }
  subclassEntityNames.add(name);
  if (persistentClass.hasPojoRepresentation()) {
    entityNameByInheritenceClassMap.put(persistentClass.getMappedClass(),persistentClass.getEntityName());
    iter=persistentClass.getSubclassIterator();
    while (iter.hasNext()) {
      final PersistentClass pc=(PersistentClass)iter.next();
      entityNameByInheritenceClassMap.put(pc.getMappedClass(),pc.getEntityName());
    }
  }
  tuplizerMapping=new EntityEntityModeToTuplizerMapping(persistentClass,this);
}
