{
  PendingPut toClean=null;
  if (lock) {
    pendingLock.lock();
  }
  try {
    long overaged=now - this.pendingPutOveragePeriod;
    long recent=now - this.pendingPutRecentPeriod;
    int pos=0;
    while (pendingQueue.size() > pos) {
      WeakReference<PendingPut> ref=pendingQueue.get(pos);
      PendingPut item=ref.get();
      if (item == null || item.completed) {
        pendingQueue.remove(pos);
      }
 else       if (item.timestamp < overaged) {
        pendingQueue.remove(pos);
        overagePendingQueue.add(ref);
      }
 else       if (item.timestamp >= recent) {
        break;
      }
 else       if (pos > 2) {
        break;
      }
 else {
        pos++;
      }
    }
    long mustCleanTime=now - this.maxPendingPutDelay;
    while (overagePendingQueue.size() > 0) {
      WeakReference<PendingPut> ref=overagePendingQueue.get(0);
      PendingPut item=ref.get();
      if (item == null || item.completed) {
        overagePendingQueue.remove(0);
      }
 else {
        if (item.timestamp < mustCleanTime) {
          overagePendingQueue.remove(0);
          toClean=item;
        }
        break;
      }
    }
  }
  finally {
    if (lock) {
      pendingLock.unlock();
    }
  }
  if (toClean != null) {
    PendingPutMap map=pendingPuts.get(toClean.key);
    if (map != null) {
      if (map.acquireLock(100,TimeUnit.MILLISECONDS)) {
        try {
          PendingPut cleaned=map.remove(toClean.owner);
          if (toClean.equals(cleaned) == false) {
            map.put(cleaned);
          }
 else           if (map.size() == 0) {
            pendingPuts.remove(toClean.key);
          }
        }
  finally {
          map.releaseLock();
        }
      }
 else {
        restorePendingPut(toClean);
      }
    }
  }
}
