{
  String[] columnNames=new String[getColumnSpan()];
  String[] referencedColumnNames=new String[getColumnSpan()];
  final Iterator referencedColumnItr;
  if (isReferenceToPrimaryKey()) {
    referencedColumnItr=referencedTable.getPrimaryKey().getColumnIterator();
  }
 else {
    referencedColumnItr=referencedColumns.iterator();
  }
  Iterator columnItr=getColumnIterator();
  int i=0;
  while (columnItr.hasNext()) {
    columnNames[i]=((Column)columnItr.next()).getQuotedName(dialect);
    referencedColumnNames[i]=((Column)referencedColumnItr.next()).getQuotedName(dialect);
    i++;
  }
  final String result=dialect.getAddForeignKeyConstraintString(constraintName,columnNames,referencedTable.getQualifiedName(dialect,defaultCatalog,defaultSchema),referencedColumnNames,isReferenceToPrimaryKey());
  return cascadeDeleteEnabled && dialect.supportsCascadeDelete() ? result + " on delete cascade" : result;
}
