{
  CyclicBarrier loadBarrier=new CyclicBarrier(2);
  CountDownLatch flushLatch=new CountDownLatch(2);
  CountDownLatch commitLatch=new CountDownLatch(1);
  Future<Boolean> first=updateFlushWait(itemId,loadBarrier,null,flushLatch,commitLatch);
  Future<Boolean> second=updateFlushWait(itemId,loadBarrier,null,flushLatch,commitLatch);
  awaitOrThrow(flushLatch);
  Map contents=Caches.entrySet(entityCache).toMap();
  assertEquals(1,contents.size());
  assertEquals(FutureUpdate.class,contents.get(itemId).getClass());
  commitLatch.countDown();
  first.get(WAIT_TIMEOUT,TimeUnit.SECONDS);
  second.get(WAIT_TIMEOUT,TimeUnit.SECONDS);
  contents=Caches.entrySet(entityCache).toMap();
  assertEquals(1,contents.size());
  Object value=contents.get(itemId);
  if (value instanceof FutureUpdate) {
    TIME_SERVICE.advance(TIMEOUT + 1);
    assertNull(entityCache.get(itemId));
    contents=Caches.entrySet(entityCache).toMap();
    assertEquals(Collections.EMPTY_MAP,contents);
  }
 else {
    assertNotNull(value);
    assertEquals(StandardCacheEntryImpl.class,value.getClass());
    TIME_SERVICE.advance(TIMEOUT + 1);
    assertEquals(value,entityCache.get(itemId));
  }
}
