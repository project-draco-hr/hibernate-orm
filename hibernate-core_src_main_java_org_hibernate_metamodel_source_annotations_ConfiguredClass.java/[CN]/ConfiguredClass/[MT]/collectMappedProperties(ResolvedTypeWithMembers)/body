{
  Set<String> transientFieldNames=new HashSet<String>();
  Set<String> transientMethodNames=new HashSet<String>();
  populateTransientFieldAndMethodLists(transientFieldNames,transientMethodNames);
  ResolvedTypeWithMembers resolvedType=null;
  for (  HierarchicType hierarchicType : resolvedTypes.allTypesAndOverrides()) {
    if (hierarchicType.getType().getErasedType().equals(clazz)) {
      resolvedType=ReflectionHelper.resolveMemberTypes(hierarchicType.getType());
      break;
    }
  }
  if (resolvedType == null) {
    throw new AssertionFailure("Unable to resolve types for " + clazz.getName());
  }
  List<MappedProperty> properties=new ArrayList<MappedProperty>();
  Set<String> explicitlyConfiguredMemberNames=createExplicitlyConfiguredAccessProperties(properties,resolvedType);
  if (AccessType.FIELD.equals(classAccessType)) {
    Field fields[]=clazz.getDeclaredFields();
    Field.setAccessible(fields,true);
    for (    Field field : fields) {
      if (isPersistentMember(transientFieldNames,explicitlyConfiguredMemberNames,field)) {
        properties.add(createMappedProperty(field,resolvedType));
      }
    }
  }
 else {
    Method[] methods=clazz.getDeclaredMethods();
    Method.setAccessible(methods,true);
    for (    Method method : methods) {
      if (isPersistentMember(transientMethodNames,explicitlyConfiguredMemberNames,method)) {
        properties.add(createMappedProperty(method,resolvedType));
      }
    }
  }
  return properties;
}
