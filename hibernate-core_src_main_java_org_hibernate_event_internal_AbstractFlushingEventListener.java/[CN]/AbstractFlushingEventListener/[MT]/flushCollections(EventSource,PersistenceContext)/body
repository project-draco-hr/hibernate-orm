{
  LOG.trace("Processing unreferenced collections");
  Iterator<Map.Entry<PersistentCollection,CollectionEntry>> entriesIterator=IdentityMap.entriesIterator(persistenceContext.getCollectionEntries());
  while (entriesIterator.hasNext()) {
    Map.Entry<PersistentCollection,CollectionEntry> me=entriesIterator.next();
    CollectionEntry ce=me.getValue();
    if (!ce.isReached() && !ce.isIgnore()) {
      Collections.processUnreachableCollection(me.getKey(),session);
    }
  }
  LOG.trace("Scheduling collection removes/(re)creates/updates");
  entriesIterator=IdentityMap.entriesIterator(persistenceContext.getCollectionEntries());
  ActionQueue actionQueue=session.getActionQueue();
  while (entriesIterator.hasNext()) {
    Map.Entry<PersistentCollection,CollectionEntry> me=entriesIterator.next();
    PersistentCollection coll=me.getKey();
    CollectionEntry ce=me.getValue();
    if (ce.isDorecreate()) {
      session.getInterceptor().onCollectionRecreate(coll,ce.getCurrentKey());
      actionQueue.addAction(new CollectionRecreateAction(coll,ce.getCurrentPersister(),ce.getCurrentKey(),session));
    }
    if (ce.isDoremove()) {
      session.getInterceptor().onCollectionRemove(coll,ce.getLoadedKey());
      actionQueue.addAction(new CollectionRemoveAction(coll,ce.getLoadedPersister(),ce.getLoadedKey(),ce.isSnapshotEmpty(coll),session));
    }
    if (ce.isDoupdate()) {
      session.getInterceptor().onCollectionUpdate(coll,ce.getLoadedKey());
      actionQueue.addAction(new CollectionUpdateAction(coll,ce.getLoadedPersister(),ce.getLoadedKey(),ce.isSnapshotEmpty(coll),session));
    }
  }
  actionQueue.sortCollectionActions();
}
