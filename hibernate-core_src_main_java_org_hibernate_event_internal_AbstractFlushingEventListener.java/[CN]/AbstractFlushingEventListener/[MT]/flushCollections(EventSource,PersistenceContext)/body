{
  LOG.trace("Processing unreferenced collections");
  final Map.Entry<PersistentCollection,CollectionEntry>[] entries=IdentityMap.concurrentEntries((Map<PersistentCollection,CollectionEntry>)persistenceContext.getCollectionEntries());
  final int count=entries.length;
  for (  Map.Entry<PersistentCollection,CollectionEntry> me : entries) {
    CollectionEntry ce=me.getValue();
    if (!ce.isReached() && !ce.isIgnore()) {
      Collections.processUnreachableCollection(me.getKey(),session);
    }
  }
  LOG.trace("Scheduling collection removes/(re)creates/updates");
  ActionQueue actionQueue=session.getActionQueue();
  for (  Map.Entry<PersistentCollection,CollectionEntry> me : IdentityMap.concurrentEntries((Map<PersistentCollection,CollectionEntry>)persistenceContext.getCollectionEntries())) {
    PersistentCollection coll=me.getKey();
    CollectionEntry ce=me.getValue();
    if (ce.isDorecreate()) {
      session.getInterceptor().onCollectionRecreate(coll,ce.getCurrentKey());
      actionQueue.addAction(new CollectionRecreateAction(coll,ce.getCurrentPersister(),ce.getCurrentKey(),session));
    }
    if (ce.isDoremove()) {
      session.getInterceptor().onCollectionRemove(coll,ce.getLoadedKey());
      actionQueue.addAction(new CollectionRemoveAction(coll,ce.getLoadedPersister(),ce.getLoadedKey(),ce.isSnapshotEmpty(coll),session));
    }
    if (ce.isDoupdate()) {
      session.getInterceptor().onCollectionUpdate(coll,ce.getLoadedKey());
      actionQueue.addAction(new CollectionUpdateAction(coll,ce.getLoadedPersister(),ce.getLoadedKey(),ce.isSnapshotEmpty(coll),session));
    }
    if (!coll.wasInitialized() && coll.hasQueuedOperations()) {
      actionQueue.addAction(new QueuedOperationCollectionAction(coll,ce.getLoadedPersister(),ce.getLoadedKey(),session));
    }
  }
  actionQueue.sortCollectionActions();
  return count;
}
