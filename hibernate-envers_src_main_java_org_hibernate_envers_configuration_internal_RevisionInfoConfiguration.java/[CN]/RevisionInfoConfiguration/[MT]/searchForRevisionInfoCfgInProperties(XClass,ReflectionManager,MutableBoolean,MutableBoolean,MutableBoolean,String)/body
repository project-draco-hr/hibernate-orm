{
  for (  XProperty property : clazz.getDeclaredProperties(accessType)) {
    final RevisionNumber revisionNumber=property.getAnnotation(RevisionNumber.class);
    final RevisionTimestamp revisionTimestamp=property.getAnnotation(RevisionTimestamp.class);
    final ModifiedEntityNames modifiedEntityNames=property.getAnnotation(ModifiedEntityNames.class);
    if (revisionNumber != null) {
      if (revisionNumberFound.isSet()) {
        throw new MappingException("Only one property may be annotated with @RevisionNumber!");
      }
      final XClass revisionNumberClass=property.getType();
      if (reflectionManager.equals(revisionNumberClass,Integer.class) || reflectionManager.equals(revisionNumberClass,Integer.TYPE)) {
        revisionInfoIdData=new PropertyData(property.getName(),property.getName(),accessType,null);
        revisionNumberFound.set();
      }
 else       if (reflectionManager.equals(revisionNumberClass,Long.class) || reflectionManager.equals(revisionNumberClass,Long.TYPE)) {
        revisionInfoIdData=new PropertyData(property.getName(),property.getName(),accessType,null);
        revisionNumberFound.set();
        revisionPropType="long";
      }
 else {
        throw new MappingException("The field annotated with @RevisionNumber must be of type " + "int, Integer, long or Long");
      }
      final Column revisionPropColumn=property.getAnnotation(Column.class);
      if (revisionPropColumn != null) {
        revisionPropSqlType=revisionPropColumn.columnDefinition();
      }
    }
    if (revisionTimestamp != null) {
      if (revisionTimestampFound.isSet()) {
        throw new MappingException("Only one property may be annotated with @RevisionTimestamp!");
      }
      final XClass revisionTimestampClass=property.getType();
      if (reflectionManager.equals(revisionTimestampClass,Long.class) || reflectionManager.equals(revisionTimestampClass,Long.TYPE) || reflectionManager.equals(revisionTimestampClass,Date.class)|| reflectionManager.equals(revisionTimestampClass,java.sql.Date.class)) {
        revisionInfoTimestampData=new PropertyData(property.getName(),property.getName(),accessType,null);
        revisionTimestampFound.set();
      }
 else {
        throw new MappingException("The field annotated with @RevisionTimestamp must be of type " + "long, Long, java.util.Date or java.sql.Date");
      }
    }
    if (modifiedEntityNames != null) {
      if (modifiedEntityNamesFound.isSet()) {
        throw new MappingException("Only one property may be annotated with @ModifiedEntityNames!");
      }
      final XClass modifiedEntityNamesClass=property.getType();
      if (reflectionManager.equals(modifiedEntityNamesClass,Set.class) && reflectionManager.equals(property.getElementClass(),String.class)) {
        modifiedEntityNamesData=new PropertyData(property.getName(),property.getName(),accessType,null);
        modifiedEntityNamesFound.set();
      }
 else {
        throw new MappingException("The field annotated with @ModifiedEntityNames must be of Set<String> type.");
      }
    }
  }
}
