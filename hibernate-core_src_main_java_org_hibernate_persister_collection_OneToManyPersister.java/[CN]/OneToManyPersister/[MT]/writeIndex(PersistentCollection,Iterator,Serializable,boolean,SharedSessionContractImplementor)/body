{
  if (isInverse && hasIndex && !indexContainsFormula&& ArrayHelper.countTrue(indexColumnIsSettable) > 0) {
    try {
      if (entries.hasNext()) {
        int nextIndex=resetIndex ? 0 : getSize(id,session);
        Expectation expectation=Expectations.appropriateExpectation(getUpdateCheckStyle());
        while (entries.hasNext()) {
          final Object entry=entries.next();
          if (entry != null && collection.entryExists(entry,nextIndex)) {
            int offset=1;
            PreparedStatement st=null;
            boolean callable=isUpdateCallable();
            boolean useBatch=expectation.canBeBatched();
            String sql=getSQLUpdateRowString();
            if (useBatch) {
              if (recreateBatchKey == null) {
                recreateBatchKey=new BasicBatchKey(getRole() + "#RECREATE",expectation);
              }
              st=session.getJdbcCoordinator().getBatch(recreateBatchKey).getBatchStatement(sql,callable);
            }
 else {
              st=session.getJdbcCoordinator().getStatementPreparer().prepareStatement(sql,callable);
            }
            try {
              offset+=expectation.prepare(st);
              if (hasIdentifier) {
                offset=writeIdentifier(st,collection.getIdentifier(entry,nextIndex),offset,session);
              }
              offset=writeIndex(st,collection.getIndex(entry,nextIndex,this),offset,session);
              offset=writeElement(st,collection.getElement(entry),offset,session);
              if (useBatch) {
                session.getJdbcCoordinator().getBatch(recreateBatchKey).addToBatch();
              }
 else {
                expectation.verifyOutcome(session.getJdbcCoordinator().getResultSetReturn().executeUpdate(st),st,-1);
              }
            }
 catch (            SQLException sqle) {
              if (useBatch) {
                session.getJdbcCoordinator().abortBatch();
              }
              throw sqle;
            }
 finally {
              if (!useBatch) {
                session.getJdbcCoordinator().getResourceRegistry().release(st);
                session.getJdbcCoordinator().afterStatementExecution();
              }
            }
          }
          nextIndex++;
        }
      }
    }
 catch (    SQLException sqle) {
      throw sqlExceptionHelper.convert(sqle,"could not update collection: " + MessageHelper.collectionInfoString(this,collection,id,session),getSQLUpdateRowString());
    }
  }
}
