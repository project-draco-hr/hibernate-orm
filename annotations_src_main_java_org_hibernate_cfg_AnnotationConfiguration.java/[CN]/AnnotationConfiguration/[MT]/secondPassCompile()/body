{
  log.debug("Execute first pass mapping processing");
{
    List<XClass> tempAnnotatedClasses=new ArrayList<XClass>(annotatedClasses.size());
    for (    XClass clazz : annotatedClasses) {
      if (clazz.isAnnotationPresent(Entity.class)) {
        annotatedClassEntities.put(clazz.getName(),clazz);
        tempAnnotatedClasses.add(clazz);
      }
 else       if (clazz.isAnnotationPresent(MappedSuperclass.class)) {
        tempAnnotatedClasses.add(clazz);
      }
    }
    annotatedClasses=tempAnnotatedClasses;
  }
  if (!isDefaultProcessed) {
    final Object isDelimited=reflectionManager.getDefaults().get("delimited-identifier");
    if (isDelimited != null && isDelimited == Boolean.TRUE) {
      getProperties().put(Environment.GLOBALLY_QUOTED_IDENTIFIERS,"true");
    }
    AnnotationBinder.bindDefaults(createExtendedMappings());
    isDefaultProcessed=true;
  }
  if (precedence == null) {
    precedence=getProperties().getProperty(ARTEFACT);
  }
  if (precedence == null) {
    precedence=DEFAULT_PRECEDENCE;
  }
  StringTokenizer precedences=new StringTokenizer(precedence,",; ",false);
  if (!precedences.hasMoreElements()) {
    throw new MappingException(ARTEFACT + " cannot be empty: " + precedence);
  }
  while (precedences.hasMoreElements()) {
    String artifact=(String)precedences.nextElement();
    removeConflictedArtifact(artifact);
    processArtifactsOfType(artifact);
  }
  int cacheNbr=caches.size();
  for (int index=0; index < cacheNbr; index++) {
    CacheHolder cacheHolder=caches.get(index);
    if (cacheHolder.isClass) {
      super.setCacheConcurrencyStrategy(cacheHolder.role,cacheHolder.usage,cacheHolder.region,cacheHolder.cacheLazy);
    }
 else {
      super.setCollectionCacheConcurrencyStrategy(cacheHolder.role,cacheHolder.usage,cacheHolder.region);
    }
  }
  caches.clear();
  try {
    inSecondPass=true;
    processSecondPassesOfType(SetSimpleValueTypeSecondPass.class);
    processSecondPassesOfType(CopyIdentifierComponentSecondPass.class);
    processFkSecondPassInOrder();
    processSecondPassesOfType(CreateKeySecondPass.class);
    processSecondPassesOfType(SecondaryTableSecondPass.class);
    super.secondPassCompile();
    inSecondPass=false;
  }
 catch (  RecoverableException e) {
    throw (RuntimeException)e.getCause();
  }
  Iterator<Map.Entry<Table,List<UniqueConstraintHolder>>> tables=uniqueConstraintHoldersByTable.entrySet().iterator();
  while (tables.hasNext()) {
    final Map.Entry<Table,List<UniqueConstraintHolder>> entry=tables.next();
    final Table table=entry.getKey();
    final List<UniqueConstraintHolder> uniqueConstraints=entry.getValue();
    int uniqueIndexPerTable=0;
    for (    UniqueConstraintHolder holder : uniqueConstraints) {
      uniqueIndexPerTable++;
      final String keyName=StringHelper.isEmpty(holder.getName()) ? "key" + uniqueIndexPerTable : holder.getName();
      buildUniqueKeyFromColumnNames(table,keyName,holder.getColumns());
    }
  }
  applyConstraintsToDDL();
}
