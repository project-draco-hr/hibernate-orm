{
  log.debug("Execute first pass mapping processing");
{
    List<XClass> tempAnnotatedClasses=new ArrayList<XClass>(annotatedClasses.size());
    for (    XClass clazz : annotatedClasses) {
      if (clazz.isAnnotationPresent(Entity.class)) {
        annotatedClassEntities.put(clazz.getName(),clazz);
        tempAnnotatedClasses.add(clazz);
      }
 else       if (clazz.isAnnotationPresent(MappedSuperclass.class)) {
        tempAnnotatedClasses.add(clazz);
      }
    }
    annotatedClasses=tempAnnotatedClasses;
  }
  if (!isDefaultProcessed) {
    AnnotationBinder.bindDefaults(createExtendedMappings());
    isDefaultProcessed=true;
  }
  if (precedence == null) {
    precedence=getProperties().getProperty(ARTEFACT);
  }
  if (precedence == null) {
    precedence=DEFAULT_PRECEDENCE;
  }
  StringTokenizer precedences=new StringTokenizer(precedence,",; ",false);
  if (!precedences.hasMoreElements()) {
    throw new MappingException(ARTEFACT + " cannot be empty: " + precedence);
  }
  while (precedences.hasMoreElements()) {
    String artifact=(String)precedences.nextElement();
    removeConflictedArtifact(artifact);
    processArtifactsOfType(artifact);
  }
  int cacheNbr=caches.size();
  for (int index=0; index < cacheNbr; index++) {
    CacheHolder cacheHolder=caches.get(index);
    if (cacheHolder.isClass) {
      super.setCacheConcurrencyStrategy(cacheHolder.role,cacheHolder.usage,cacheHolder.region,cacheHolder.cacheLazy);
    }
 else {
      super.setCollectionCacheConcurrencyStrategy(cacheHolder.role,cacheHolder.usage,cacheHolder.region);
    }
  }
  caches.clear();
  try {
    inSecondPass=true;
    Iterator iter=secondPasses.iterator();
    while (iter.hasNext()) {
      SecondPass sp=(SecondPass)iter.next();
      if (sp instanceof SetSimpleValueTypeSecondPass) {
        sp.doSecondPass(classes);
        iter.remove();
      }
    }
    processFkSecondPassInOrder();
    iter=secondPasses.iterator();
    while (iter.hasNext()) {
      SecondPass sp=(SecondPass)iter.next();
      if (sp instanceof CreateKeySecondPass) {
        sp.doSecondPass(classes);
        iter.remove();
      }
    }
    iter=secondPasses.iterator();
    while (iter.hasNext()) {
      SecondPass sp=(SecondPass)iter.next();
      if (sp instanceof SecondaryTableSecondPass) {
        sp.doSecondPass(classes);
        iter.remove();
      }
    }
    super.secondPassCompile();
    inSecondPass=false;
  }
 catch (  RecoverableException e) {
    throw (RuntimeException)e.getCause();
  }
  Iterator tables=tableUniqueConstraints.entrySet().iterator();
  Table table;
  Map.Entry entry;
  String keyName;
  int uniqueIndexPerTable;
  while (tables.hasNext()) {
    entry=(Map.Entry)tables.next();
    table=(Table)entry.getKey();
    List<String[]> uniqueConstraints=(List<String[]>)entry.getValue();
    uniqueIndexPerTable=0;
    for (    String[] columnNames : uniqueConstraints) {
      keyName="key" + uniqueIndexPerTable++;
      buildUniqueKeyFromColumnNames(columnNames,table,keyName);
    }
  }
  applyConstraintsToDDL();
}
