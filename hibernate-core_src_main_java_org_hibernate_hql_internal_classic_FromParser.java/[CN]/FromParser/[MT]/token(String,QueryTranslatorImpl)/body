{
  String lcToken=token.toLowerCase();
  if (lcToken.equals(",")) {
    if (!(expectingJoin | expectingAs))     throw new QueryException("unexpected token: ,");
    expectingJoin=false;
    expectingAs=false;
  }
 else   if (lcToken.equals("join")) {
    if (!afterJoinType) {
      if (!(expectingJoin | expectingAs))       throw new QueryException("unexpected token: join");
      joinType=JoinType.INNER_JOIN;
      expectingJoin=false;
      expectingAs=false;
    }
 else {
      afterJoinType=false;
    }
  }
 else   if (lcToken.equals("fetch")) {
    if (q.isShallowQuery())     throw new QueryException(QueryTranslator.ERROR_CANNOT_FETCH_WITH_ITERATE);
    if (joinType == JoinType.NONE)     throw new QueryException("unexpected token: fetch");
    if (joinType == JoinType.FULL_JOIN || joinType == JoinType.RIGHT_OUTER_JOIN) {
      throw new QueryException("fetch may only be used with inner join or left outer join");
    }
    afterFetch=true;
  }
 else   if (lcToken.equals("outer")) {
    if (!afterJoinType || (joinType != JoinType.LEFT_OUTER_JOIN && joinType != JoinType.RIGHT_OUTER_JOIN)) {
      throw new QueryException("unexpected token: outer");
    }
  }
 else   if (JOIN_TYPES.containsKey(lcToken)) {
    if (!(expectingJoin | expectingAs))     throw new QueryException("unexpected token: " + token);
    joinType=JOIN_TYPES.get(lcToken);
    afterJoinType=true;
    expectingJoin=false;
    expectingAs=false;
  }
 else   if (lcToken.equals("class")) {
    if (!afterIn)     throw new QueryException("unexpected token: class");
    if (joinType != JoinType.NONE)     throw new QueryException("outer or full join must be followed by path expression");
    afterClass=true;
  }
 else   if (lcToken.equals("in")) {
    if (alias == null) {
      memberDeclarations=true;
      afterMemberDeclarations=false;
    }
 else     if (!expectingIn) {
      throw new QueryException("unexpected token: in");
    }
 else {
      afterIn=true;
      expectingIn=false;
    }
  }
 else   if (lcToken.equals("as")) {
    if (!expectingAs)     throw new QueryException("unexpected token: as");
    afterAs=true;
    expectingAs=false;
  }
 else   if ("(".equals(token)) {
    if (!memberDeclarations)     throw new QueryException("unexpected token: (");
    expectingPathExpression=true;
  }
 else   if (")".equals(token)) {
    afterMemberDeclarations=true;
  }
 else {
    if (afterJoinType)     throw new QueryException("join expected: " + token);
    if (expectingJoin)     throw new QueryException("unexpected token: " + token);
    if (expectingIn)     throw new QueryException("in expected: " + token);
    if (afterAs || expectingAs) {
      if (entityName != null) {
        q.setAliasName(token,entityName);
      }
 else       if (collectionName != null) {
        q.setAliasName(token,collectionName);
      }
 else {
        throw new QueryException("unexpected: as " + token);
      }
      afterAs=false;
      expectingJoin=true;
      expectingAs=false;
      entityName=null;
      collectionName=null;
      memberDeclarations=false;
      expectingPathExpression=false;
      afterMemberDeclarations=false;
    }
 else     if (afterIn) {
      if (alias == null)       throw new QueryException("alias not specified for: " + token);
      if (joinType != JoinType.NONE)       throw new QueryException("outer or full join must be followed by path expression");
      if (afterClass) {
        Queryable p=q.getEntityPersisterUsingImports(token);
        if (p == null)         throw new QueryException("persister not found: " + token);
        q.addFromClass(alias,p);
      }
 else {
        peParser.setJoinType(JoinType.INNER_JOIN);
        peParser.setUseThetaStyleJoin(true);
        ParserHelper.parse(peParser,q.unalias(token),ParserHelper.PATH_SEPARATORS,q);
        if (!peParser.isCollectionValued())         throw new QueryException("path expression did not resolve to collection: " + token);
        String nm=peParser.addFromCollection(q);
        q.setAliasName(alias,nm);
      }
      alias=null;
      afterIn=false;
      afterClass=false;
      expectingJoin=true;
    }
 else     if (memberDeclarations && expectingPathExpression) {
      expectingAs=true;
      peParser.setJoinType(JoinType.INNER_JOIN);
      peParser.setUseThetaStyleJoin(false);
      ParserHelper.parse(peParser,q.unalias(token),ParserHelper.PATH_SEPARATORS,q);
      if (!peParser.isCollectionValued())       throw new QueryException("path expression did not resolve to collection: " + token);
      collectionName=peParser.addFromCollection(q);
      expectingPathExpression=false;
      memberDeclarations=false;
    }
 else {
      Queryable p=q.getEntityPersisterUsingImports(token);
      if (p != null) {
        if (joinType != JoinType.NONE)         throw new QueryException("outer or full join must be followed by path expression");
        entityName=q.createNameFor(p.getEntityName());
        q.addFromClass(entityName,p);
        expectingAs=true;
      }
 else       if (token.indexOf('.') < 0) {
        alias=token;
        expectingIn=true;
      }
 else {
        if (joinType != JoinType.NONE) {
          peParser.setJoinType(joinType);
        }
 else {
          peParser.setJoinType(JoinType.INNER_JOIN);
        }
        peParser.setUseThetaStyleJoin(q.isSubquery());
        ParserHelper.parse(peParser,q.unalias(token),ParserHelper.PATH_SEPARATORS,q);
        entityName=peParser.addFromAssociation(q);
        joinType=JoinType.NONE;
        peParser.setJoinType(JoinType.INNER_JOIN);
        if (afterFetch) {
          peParser.fetch(q,entityName);
          afterFetch=false;
        }
        expectingAs=true;
      }
    }
  }
}
