{
  this.collection=createCollection(propertyHolder.getPersistentClass());
  String role=StringHelper.qualify(propertyHolder.getPath(),propertyName);
  LOG.debugf("Collection role: %s",role);
  collection.setRole(role);
  collection.setNodeName(propertyName);
  collection.setMappedByProperty(mappedBy);
  if (property.isAnnotationPresent(MapKeyColumn.class) && mapKeyPropertyName != null) {
    throw new AnnotationException("Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey " + "on the same collection: " + StringHelper.qualify(propertyHolder.getPath(),propertyName));
  }
  if (explicitType != null) {
    final TypeDef typeDef=mappings.getTypeDef(explicitType);
    if (typeDef == null) {
      collection.setTypeName(explicitType);
      collection.setTypeParameters(explicitTypeParameters);
    }
 else {
      collection.setTypeName(typeDef.getTypeClass());
      collection.setTypeParameters(typeDef.getParameters());
    }
  }
  defineFetchingStrategy();
  collection.setBatchSize(batchSize);
  collection.setMutable(!property.isAnnotationPresent(Immutable.class));
  boolean isMappedBy=!BinderHelper.isEmptyAnnotationValue(mappedBy);
  final OptimisticLock lockAnn=property.getAnnotation(OptimisticLock.class);
  final boolean includeInOptimisticLockChecks=(lockAnn != null) ? !lockAnn.excluded() : !isMappedBy;
  collection.setOptimisticLocked(includeInOptimisticLockChecks);
  Persister persisterAnn=property.getAnnotation(Persister.class);
  if (persisterAnn != null) {
    collection.setCollectionPersisterClass(persisterAnn.impl());
  }
  applySortingAndOrdering(collection);
  if (StringHelper.isNotEmpty(cacheConcurrencyStrategy)) {
    collection.setCacheConcurrencyStrategy(cacheConcurrencyStrategy);
    collection.setCacheRegionName(cacheRegionName);
  }
  SQLInsert sqlInsert=property.getAnnotation(SQLInsert.class);
  SQLUpdate sqlUpdate=property.getAnnotation(SQLUpdate.class);
  SQLDelete sqlDelete=property.getAnnotation(SQLDelete.class);
  SQLDeleteAll sqlDeleteAll=property.getAnnotation(SQLDeleteAll.class);
  Loader loader=property.getAnnotation(Loader.class);
  if (sqlInsert != null) {
    collection.setCustomSQLInsert(sqlInsert.sql().trim(),sqlInsert.callable(),ExecuteUpdateResultCheckStyle.fromExternalName(sqlInsert.check().toString().toLowerCase()));
  }
  if (sqlUpdate != null) {
    collection.setCustomSQLUpdate(sqlUpdate.sql(),sqlUpdate.callable(),ExecuteUpdateResultCheckStyle.fromExternalName(sqlUpdate.check().toString().toLowerCase()));
  }
  if (sqlDelete != null) {
    collection.setCustomSQLDelete(sqlDelete.sql(),sqlDelete.callable(),ExecuteUpdateResultCheckStyle.fromExternalName(sqlDelete.check().toString().toLowerCase()));
  }
  if (sqlDeleteAll != null) {
    collection.setCustomSQLDeleteAll(sqlDeleteAll.sql(),sqlDeleteAll.callable(),ExecuteUpdateResultCheckStyle.fromExternalName(sqlDeleteAll.check().toString().toLowerCase()));
  }
  if (loader != null) {
    collection.setLoaderName(loader.namedQuery());
  }
  if (isMappedBy && (property.isAnnotationPresent(JoinColumn.class) || property.isAnnotationPresent(JoinColumns.class) || propertyHolder.getJoinTable(property) != null)) {
    String message="Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: ";
    message+=StringHelper.qualify(propertyHolder.getPath(),propertyName);
    throw new AnnotationException(message);
  }
  collection.setInverse(isMappedBy);
  if (!oneToMany && isMappedBy) {
    mappings.addMappedBy(getCollectionType().getName(),mappedBy,propertyName);
  }
  XClass collectionType=getCollectionType();
  if (inheritanceStatePerClass == null)   throw new AssertionFailure("inheritanceStatePerClass not set");
  SecondPass sp=getSecondPass(fkJoinColumns,joinColumns,inverseJoinColumns,elementColumns,mapKeyColumns,mapKeyManyToManyColumns,isEmbedded,property,collectionType,ignoreNotFound,oneToMany,tableBinder,mappings);
  if (collectionType.isAnnotationPresent(Embeddable.class) || property.isAnnotationPresent(ElementCollection.class)) {
    mappings.addSecondPass(sp,!isMappedBy);
  }
 else {
    mappings.addSecondPass(sp,!isMappedBy);
  }
  mappings.addCollection(collection);
  PropertyBinder binder=new PropertyBinder();
  binder.setName(propertyName);
  binder.setValue(collection);
  binder.setCascade(cascadeStrategy);
  if (cascadeStrategy != null && cascadeStrategy.indexOf("delete-orphan") >= 0) {
    collection.setOrphanDelete(true);
  }
  binder.setAccessType(accessType);
  binder.setProperty(property);
  binder.setInsertable(insertable);
  binder.setUpdatable(updatable);
  Property prop=binder.makeProperty();
  if (!declaringClassSet)   throw new AssertionFailure("DeclaringClass is not set in CollectionBinder while binding");
  propertyHolder.addProperty(prop,declaringClass);
}
