{
  final LockOptions lockOptions=parameters.getLockOptions();
  if (lockOptions == null || (lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0)) {
    return sql;
  }
  if (shouldUseFollowOnLocking(parameters,dialect,afterLoadActions)) {
    return sql;
  }
  final LockOptions locks=new LockOptions(lockOptions.getLockMode());
  final Map<String,String[]> keyColumnNames=dialect.forUpdateOfColumns() ? new HashMap<String,String[]>() : null;
  locks.setScope(lockOptions.getScope());
  locks.setTimeOut(lockOptions.getTimeOut());
  for (  Map.Entry<String,String> entry : sqlAliasByEntityAlias.entrySet()) {
    final String userAlias=entry.getKey();
    final String drivingSqlAlias=entry.getValue();
    if (drivingSqlAlias == null) {
      throw new IllegalArgumentException("could not locate alias to apply lock mode : " + userAlias);
    }
    final QueryNode select=(QueryNode)queryTranslator.getSqlAST();
    final Lockable drivingPersister=(Lockable)select.getFromClause().findFromElementByUserOrSqlAlias(userAlias,drivingSqlAlias).getQueryable();
    final String sqlAlias=drivingPersister.getRootTableAlias(drivingSqlAlias);
    final LockMode effectiveLockMode=lockOptions.getEffectiveLockMode(userAlias);
    locks.setAliasSpecificLockMode(sqlAlias,effectiveLockMode);
    if (keyColumnNames != null) {
      keyColumnNames.put(sqlAlias,drivingPersister.getRootTableIdentifierColumnNames());
    }
  }
  return dialect.applyLocksToSql(sql,locks,keyColumnNames);
}
