{
  EventCache copyCache=new EventCache();
  onMerge(event,copyCache);
  Map transientCopyCache=getTransientCopyCache(event,copyCache);
  if (transientCopyCache.size() > 0) {
    retryMergeTransientEntities(event,transientCopyCache,copyCache,true);
    transientCopyCache=getTransientCopyCache(event,copyCache);
    if (transientCopyCache.size() > 0) {
      Set transientEntityNames=new HashSet();
      for (Iterator it=transientCopyCache.entrySet().iterator(); it.hasNext(); ) {
        Object transientEntity=((Map.Entry)it.next()).getKey();
        String transientEntityName=event.getSession().guessEntityName(transientEntity);
        transientEntityNames.add(transientEntityName);
        LOG.trace("Transient instance could not be processed by merge when checking nullability: " + transientEntityName + "["+ transientEntity+ "]");
      }
      if (isNullabilityCheckedGlobal(event.getSession()))       throw new TransientObjectException("one or more objects is an unsaved transient instance - save transient instance(s) before merging: " + transientEntityNames);
      LOG.trace("Retry saving transient instances without checking nullability");
      retryMergeTransientEntities(event,transientCopyCache,copyCache,false);
    }
  }
  copyCache.clear();
  copyCache=null;
}
