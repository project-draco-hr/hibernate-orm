{
  this.factory=factory;
  this.cacheAccessStrategy=cacheAccessStrategy;
  isLazyPropertiesCacheable=persistentClass.isLazyPropertiesCacheable();
  this.cacheEntryStructure=factory.getSettings().isStructuredCacheEntriesEnabled() ? (CacheEntryStructure)new StructuredCacheEntry(this) : (CacheEntryStructure)new UnstructuredCacheEntry();
  this.entityMetamodel=new EntityMetamodel(persistentClass,factory);
  int batch=persistentClass.getBatchSize();
  if (batch == -1) {
    batch=factory.getSettings().getDefaultBatchFetchSize();
  }
  batchSize=batch;
  hasSubselectLoadableCollections=persistentClass.hasSubselectLoadableCollections();
  propertyMapping=new BasicEntityPropertyMapping(this);
  identifierColumnSpan=persistentClass.getIdentifier().getColumnSpan();
  rootTableKeyColumnNames=new String[identifierColumnSpan];
  identifierAliases=new String[identifierColumnSpan];
  rowIdName=persistentClass.getRootTable().getRowId();
  loaderName=persistentClass.getLoaderName();
  Iterator iter=persistentClass.getIdentifier().getColumnIterator();
  int i=0;
  while (iter.hasNext()) {
    Column col=(Column)iter.next();
    rootTableKeyColumnNames[i]=col.getQuotedName(factory.getDialect());
    identifierAliases[i]=col.getAlias(factory.getDialect(),persistentClass.getRootTable());
    i++;
  }
  if (persistentClass.isVersioned()) {
    versionColumnName=((Column)persistentClass.getVersion().getColumnIterator().next()).getQuotedName(factory.getDialect());
  }
 else {
    versionColumnName=null;
  }
  sqlWhereString=StringHelper.isNotEmpty(persistentClass.getWhere()) ? "( " + persistentClass.getWhere() + ") " : null;
  sqlWhereStringTemplate=sqlWhereString == null ? null : Template.renderWhereStringTemplate(sqlWhereString,factory.getDialect(),factory.getSqlFunctionRegistry());
  final boolean lazyAvailable=isInstrumented(EntityMode.POJO);
  int hydrateSpan=entityMetamodel.getPropertySpan();
  propertyColumnSpans=new int[hydrateSpan];
  propertySubclassNames=new String[hydrateSpan];
  propertyColumnAliases=new String[hydrateSpan][];
  propertyColumnNames=new String[hydrateSpan][];
  propertyColumnFormulaTemplates=new String[hydrateSpan][];
  propertyUniqueness=new boolean[hydrateSpan];
  propertySelectable=new boolean[hydrateSpan];
  propertyColumnUpdateable=new boolean[hydrateSpan][];
  propertyColumnInsertable=new boolean[hydrateSpan][];
  HashSet thisClassProperties=new HashSet();
  lazyProperties=new HashSet();
  ArrayList lazyNames=new ArrayList();
  ArrayList lazyNumbers=new ArrayList();
  ArrayList lazyTypes=new ArrayList();
  ArrayList lazyColAliases=new ArrayList();
  iter=persistentClass.getPropertyClosureIterator();
  i=0;
  boolean foundFormula=false;
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    thisClassProperties.add(prop);
    int span=prop.getColumnSpan();
    propertyColumnSpans[i]=span;
    propertySubclassNames[i]=prop.getPersistentClass().getEntityName();
    String[] colNames=new String[span];
    String[] colAliases=new String[span];
    String[] templates=new String[span];
    Iterator colIter=prop.getColumnIterator();
    int k=0;
    while (colIter.hasNext()) {
      Selectable thing=(Selectable)colIter.next();
      colAliases[k]=thing.getAlias(factory.getDialect(),prop.getValue().getTable());
      if (thing.isFormula()) {
        foundFormula=true;
        templates[k]=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
      }
 else {
        colNames[k]=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
      }
      k++;
    }
    propertyColumnNames[i]=colNames;
    propertyColumnFormulaTemplates[i]=templates;
    propertyColumnAliases[i]=colAliases;
    if (lazyAvailable && prop.isLazy()) {
      lazyProperties.add(prop.getName());
      lazyNames.add(prop.getName());
      lazyNumbers.add(new Integer(i));
      lazyTypes.add(prop.getValue().getType());
      lazyColAliases.add(colAliases);
    }
    propertyColumnUpdateable[i]=prop.getValue().getColumnUpdateability();
    propertyColumnInsertable[i]=prop.getValue().getColumnInsertability();
    propertySelectable[i]=prop.isSelectable();
    propertyUniqueness[i]=prop.getValue().isAlternateUniqueKey();
    i++;
  }
  hasFormulaProperties=foundFormula;
  lazyPropertyColumnAliases=ArrayHelper.to2DStringArray(lazyColAliases);
  lazyPropertyNames=ArrayHelper.toStringArray(lazyNames);
  lazyPropertyNumbers=ArrayHelper.toIntArray(lazyNumbers);
  lazyPropertyTypes=ArrayHelper.toTypeArray(lazyTypes);
  ArrayList columns=new ArrayList();
  ArrayList columnsLazy=new ArrayList();
  ArrayList aliases=new ArrayList();
  ArrayList formulas=new ArrayList();
  ArrayList formulaAliases=new ArrayList();
  ArrayList formulaTemplates=new ArrayList();
  ArrayList formulasLazy=new ArrayList();
  ArrayList types=new ArrayList();
  ArrayList names=new ArrayList();
  ArrayList classes=new ArrayList();
  ArrayList templates=new ArrayList();
  ArrayList propColumns=new ArrayList();
  ArrayList joinedFetchesList=new ArrayList();
  ArrayList cascades=new ArrayList();
  ArrayList definedBySubclass=new ArrayList();
  ArrayList propColumnNumbers=new ArrayList();
  ArrayList propFormulaNumbers=new ArrayList();
  ArrayList columnSelectables=new ArrayList();
  ArrayList propNullables=new ArrayList();
  iter=persistentClass.getSubclassPropertyClosureIterator();
  while (iter.hasNext()) {
    Property prop=(Property)iter.next();
    names.add(prop.getName());
    classes.add(prop.getPersistentClass().getEntityName());
    boolean isDefinedBySubclass=!thisClassProperties.contains(prop);
    definedBySubclass.add(Boolean.valueOf(isDefinedBySubclass));
    propNullables.add(Boolean.valueOf(prop.isOptional() || isDefinedBySubclass));
    types.add(prop.getType());
    Iterator colIter=prop.getColumnIterator();
    String[] cols=new String[prop.getColumnSpan()];
    String[] forms=new String[prop.getColumnSpan()];
    int[] colnos=new int[prop.getColumnSpan()];
    int[] formnos=new int[prop.getColumnSpan()];
    int l=0;
    Boolean lazy=Boolean.valueOf(prop.isLazy() && lazyAvailable);
    while (colIter.hasNext()) {
      Selectable thing=(Selectable)colIter.next();
      if (thing.isFormula()) {
        String template=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
        formnos[l]=formulaTemplates.size();
        colnos[l]=-1;
        formulaTemplates.add(template);
        forms[l]=template;
        formulas.add(thing.getText(factory.getDialect()));
        formulaAliases.add(thing.getAlias(factory.getDialect()));
        formulasLazy.add(lazy);
      }
 else {
        String colName=thing.getTemplate(factory.getDialect(),factory.getSqlFunctionRegistry());
        colnos[l]=columns.size();
        formnos[l]=-1;
        columns.add(colName);
        cols[l]=colName;
        aliases.add(thing.getAlias(factory.getDialect(),prop.getValue().getTable()));
        columnsLazy.add(lazy);
        columnSelectables.add(Boolean.valueOf(prop.isSelectable()));
      }
      l++;
    }
    propColumns.add(cols);
    templates.add(forms);
    propColumnNumbers.add(colnos);
    propFormulaNumbers.add(formnos);
    joinedFetchesList.add(prop.getValue().getFetchMode());
    cascades.add(prop.getCascadeStyle());
  }
  subclassColumnClosure=ArrayHelper.toStringArray(columns);
  subclassColumnAliasClosure=ArrayHelper.toStringArray(aliases);
  subclassColumnLazyClosure=ArrayHelper.toBooleanArray(columnsLazy);
  subclassColumnSelectableClosure=ArrayHelper.toBooleanArray(columnSelectables);
  subclassFormulaClosure=ArrayHelper.toStringArray(formulas);
  subclassFormulaTemplateClosure=ArrayHelper.toStringArray(formulaTemplates);
  subclassFormulaAliasClosure=ArrayHelper.toStringArray(formulaAliases);
  subclassFormulaLazyClosure=ArrayHelper.toBooleanArray(formulasLazy);
  subclassPropertyNameClosure=ArrayHelper.toStringArray(names);
  subclassPropertySubclassNameClosure=ArrayHelper.toStringArray(classes);
  subclassPropertyTypeClosure=ArrayHelper.toTypeArray(types);
  subclassPropertyNullabilityClosure=ArrayHelper.toBooleanArray(propNullables);
  subclassPropertyFormulaTemplateClosure=ArrayHelper.to2DStringArray(templates);
  subclassPropertyColumnNameClosure=ArrayHelper.to2DStringArray(propColumns);
  subclassPropertyColumnNumberClosure=ArrayHelper.to2DIntArray(propColumnNumbers);
  subclassPropertyFormulaNumberClosure=ArrayHelper.to2DIntArray(propFormulaNumbers);
  subclassPropertyCascadeStyleClosure=new CascadeStyle[cascades.size()];
  iter=cascades.iterator();
  int j=0;
  while (iter.hasNext()) {
    subclassPropertyCascadeStyleClosure[j++]=(CascadeStyle)iter.next();
  }
  subclassPropertyFetchModeClosure=new FetchMode[joinedFetchesList.size()];
  iter=joinedFetchesList.iterator();
  j=0;
  while (iter.hasNext()) {
    subclassPropertyFetchModeClosure[j++]=(FetchMode)iter.next();
  }
  propertyDefinedOnSubclass=new boolean[definedBySubclass.size()];
  iter=definedBySubclass.iterator();
  j=0;
  while (iter.hasNext()) {
    propertyDefinedOnSubclass[j++]=((Boolean)iter.next()).booleanValue();
  }
  filterHelper=new FilterHelper(persistentClass.getFilterMap(),factory.getDialect(),factory.getSqlFunctionRegistry());
  temporaryIdTableName=persistentClass.getTemporaryIdTableName();
  temporaryIdTableDDL=persistentClass.getTemporaryIdTableDDL();
}
