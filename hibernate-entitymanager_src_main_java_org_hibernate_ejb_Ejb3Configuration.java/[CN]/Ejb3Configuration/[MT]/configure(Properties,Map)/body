{
  if (isConfigurationProcessed)   return this;
  isConfigurationProcessed=true;
  Properties preparedProperties=prepareProperties(properties,workingVars);
  if (workingVars == null)   workingVars=CollectionHelper.EMPTY_MAP;
  if (preparedProperties.containsKey(AvailableSettings.CFG_FILE)) {
    String cfgFileName=preparedProperties.getProperty(AvailableSettings.CFG_FILE);
    cfg.configure(cfgFileName);
  }
  cfg.addProperties(preparedProperties);
  addClassesToSessionFactory(workingVars);
  List<String> jaccKeys=new ArrayList<String>();
  Interceptor defaultInterceptor=DEFAULT_CONFIGURATION.getInterceptor();
  NamingStrategy defaultNamingStrategy=DEFAULT_CONFIGURATION.getNamingStrategy();
  Iterator propertyIt=preparedProperties.keySet().iterator();
  while (propertyIt.hasNext()) {
    Object uncastObject=propertyIt.next();
    if (uncastObject != null && uncastObject instanceof String) {
      String propertyKey=(String)uncastObject;
      if (propertyKey.startsWith(AvailableSettings.CLASS_CACHE_PREFIX)) {
        setCacheStrategy(propertyKey,preparedProperties,true,workingVars);
      }
 else       if (propertyKey.startsWith(AvailableSettings.COLLECTION_CACHE_PREFIX)) {
        setCacheStrategy(propertyKey,preparedProperties,false,workingVars);
      }
 else       if (propertyKey.startsWith(AvailableSettings.JACC_PREFIX) && !(propertyKey.equals(AvailableSettings.JACC_CONTEXT_ID) || propertyKey.equals(AvailableSettings.JACC_ENABLED))) {
        jaccKeys.add(propertyKey);
      }
    }
  }
  if (preparedProperties.containsKey(AvailableSettings.INTERCEPTOR) && (cfg.getInterceptor() == null || cfg.getInterceptor().equals(defaultInterceptor))) {
    String interceptorName=preparedProperties.getProperty(AvailableSettings.INTERCEPTOR);
    try {
      Class interceptor=classForName(interceptorName);
      cfg.setInterceptor((Interceptor)interceptor.newInstance());
    }
 catch (    ClassNotFoundException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to find interceptor class: " + interceptorName,e);
    }
catch (    IllegalAccessException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to access interceptor class: " + interceptorName,e);
    }
catch (    InstantiationException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to instanciate interceptor class: " + interceptorName,e);
    }
catch (    ClassCastException e) {
      throw new PersistenceException(getExceptionHeader() + "Interceptor class does not implement Interceptor interface: " + interceptorName,e);
    }
  }
  if (preparedProperties.containsKey(AvailableSettings.NAMING_STRATEGY) && (cfg.getNamingStrategy() == null || cfg.getNamingStrategy().equals(defaultNamingStrategy))) {
    String namingStrategyName=preparedProperties.getProperty(AvailableSettings.NAMING_STRATEGY);
    try {
      Class namingStragegy=classForName(namingStrategyName);
      cfg.setNamingStrategy((NamingStrategy)namingStragegy.newInstance());
    }
 catch (    ClassNotFoundException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to find naming strategy class: " + namingStrategyName,e);
    }
catch (    IllegalAccessException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to access naming strategy class: " + namingStrategyName,e);
    }
catch (    InstantiationException e) {
      throw new PersistenceException(getExceptionHeader() + "Unable to instanciate naming strategy class: " + namingStrategyName,e);
    }
catch (    ClassCastException e) {
      throw new PersistenceException(getExceptionHeader() + "Naming strategyy class does not implement NmaingStrategy interface: " + namingStrategyName,e);
    }
  }
  if (jaccKeys.size() > 0) {
    addSecurity(jaccKeys,preparedProperties,workingVars);
  }
  listenerConfigurator.setProperties(preparedProperties);
  listenerConfigurator.configure();
  if (!"true".equalsIgnoreCase(cfg.getProperty(Environment.AUTOCOMMIT)))   LOG.jdbcAutoCommitFalseBreaksEjb3Spec(Environment.AUTOCOMMIT);
  discardOnClose=preparedProperties.getProperty(AvailableSettings.DISCARD_PC_ON_CLOSE).equals("true");
  return this;
}
